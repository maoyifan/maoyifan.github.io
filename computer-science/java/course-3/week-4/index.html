<!DOCTYPE html><html lang="zh_Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一只猫" href="https://maoyifan.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一只猫" href="https://maoyifan.github.io/atom.xml"><link rel="alternate" type="application/json" title="一只猫" href="https://maoyifan.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.3"><link rel="canonical" href="https://maoyifan.github.io/computer-science/java/course-3/week-4/"><title>第4章 锁的优化及注意事项 - Java高并发程序设计 - Java - 计算机科学 | MYF = 一只猫 = CAT&DOG</title><meta name="generator" content="Hexo 5.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">第4章 锁的优化及注意事项</h1><div class="meta"><span class="item" title="Created: 2020-10-31 19:49:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">Posted on</span> <time itemprop="dateCreated datePublished" datetime="2020-10-31T19:49:25+08:00">2020-10-31</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">MYF</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipexw3o58j20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevgoki5j20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main id="main"><div class="inner"><div id="content" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">Home</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="In 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/" itemprop="item" rel="index" title="In Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/java/course-3/" itemprop="item" rel="index" title="In Java高并发程序设计"><span itemprop="name">Java高并发程序设计</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh_Hans"><link itemprop="mainEntityOfPage" href="https://maoyifan.github.io/computer-science/java/course-3/week-4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="MYF"><meta itemprop="description" content="CAT&DOG, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一只猫"></span><div class="body md" itemprop="articleBody"><h1 id="有助于提高锁性能的几点建议"><a class="anchor" href="#有助于提高锁性能的几点建议">#</a> 有助于提高 “锁” 性能的几点建议</h1><p><img data-src="/images/c4.1.jpg" alt=""></p><ol><li><p>减小锁持有时间<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> synMethod&#123;</span><br><span class="line">        method1();</span><br><span class="line">        method2();</span><br><span class="line">        method3();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>synMethod（）方法中，假设只有 method2（）方法是有同步需要的，而 method1 () 和 method3 () 并不需要做同步控制。如果 method1 () 和 method3 () 分别是重量级的方法，则会花费较长的 CPU 时间。此时，如果在并发量较大，使用这种对整个方法做同步的方案，会导致等待线程大量增加。因为一个线程，在进入该方法时获得内部锁，只有在所有任务都执行完后，才会释放锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> synMethod2&#123;</span><br><span class="line">        method1();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">        method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个较为优化的解决方案是，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量。<br><code>注意</code> ：减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力。<p></p></li><li><p>减小锁粒度<br>对于 HashMap 来说，最重要的两个方法就是 get () 和 put ()。一种最自然的想法就是对整个 HashMap 加锁，必然可以得到一个线程安全的对象。但是这样做，我们就认为加锁粒度太大。对于 ConcurrentHashMap，它内部进一步细分了若干个小的 HashMap，称之为段（SEGMENT) 默认情况下，一个 ConcurrentHashMap 被进一步细分为 16 个段。<br>如果需要在 ConcurrentHashMap 中增加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该被存放到哪个段中，然后对该段加锁，并完成 put（）操作。在多线程环境中，如果多个线程同时进行 put（）操作，只要被加入的表项不存放在同一个段中，则线程间便可以做到真正的并行。<br><code>缺点</code><br>减少锁粒度会引入一个新的问题，即：当系统需要取得全局锁时，其消耗的资源会比较多。仍然以 ConcurrentHashMap 类为例，虽然其 put）方法很好地分离了锁，但是当试图访问 ConcurrentHashMap 全局信息时，就会需要同时取得所有段的锁方能顺利实施。比如 ConcurrentHashMap 的 size（）方法，它将返回 ConcurrentHashMap 的有效表项的数量，即 ConcurrentHashMap 的全部有效表项之和。要获取这个信息需要取得所有子段的锁.</p></li><li><p>读写分离锁来替换独占锁<br>在之前我们已经提过，使用读写锁 ReadWriteLock 可以提高系统的性能。使用读写分离锁来替代独占锁是减小锁粒度的一种特殊情况。如果说上节中提到的减少锁粒度是通过分割数据结构实现的，那么，读写锁则是对系统功能点的分割。<br>在读多写少的场合，读写锁对系统性能是很有好处的。因为如果系统在读写数据时均只使用独占锁，那么读操作和写操作间、读操作和读操作间、写操作和写操作间均不能做到真正的并发，并且需要相互等待。而读操作本身不会影响数据的完整性和一致性。因此，理论上讲，在大部分情况下，应该可以允许多线程同时读，读写锁正是实现了这种功能.</p></li><li><p>锁分离<br>在 LinkedBlockingQueue 的实现中，take（）函数和 put () 函数分别实现了从队列中取得数据和往队列中增加数据的功能。虽然两个函数都对当前队列进行了修改操作，但由于 LinkedBlockingQueue 是基于链表的，因此，两个操作分别作用于队列的前端和尾端从理论上说，两者并不冲突。<br>如果使用独占锁，则要求在两个操作进行时获取当前队列的独占锁，那么 take）和 put（）操作就不可能真正的并发，在运行时，它们会彼此等待对方释放锁资源。在这种情况下，锁竞争会相对比较激烈，从而影响程序在高并发时的性能。因此，在 JDK 的实现中，并没有采用这样的方式，取而代之的是两把不同的锁，分离了 take () 和 put () 操作。</p></li><li><p>锁粗化<br>如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。<br>为此，虚拟机在遇到一连串连续地对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化。</p></li></ol><h1 id="java虚拟机对锁优化所做的努力"><a class="anchor" href="#java虚拟机对锁优化所做的努力">#</a> Java 虚拟机对锁优化所做的努力</h1><ol><li><p>锁偏向<br>锁偏向是一种针对加锁操作的优化手段。它的 <code>核心思想是</code> ：** 如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。** 这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。这样偏向模式会失效，因此还不如不启用偏向锁。使用 Java 虚拟机参数:-xx：+UseBiasedLocking 可以开启偏向锁。</p></li><li><p>轻量级锁<br>如果偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p></li><li><p>自旋锁<br>锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力 - 一自旋锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在几个 CPU 时钟周期后，就可以得到锁。如果这样，简单粗暴地挂起线程可能是一种得不偿失的操作。因此，系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此，虚拟机会让当前线程做几个空循环（这也是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真实地将线程在操作系统层面挂起。</p></li><li><p>锁消除<br>锁消除是一种更彻底的锁优化。Java 虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。<br>在 Java 软件开发过程中，我们必然会使用一些 JDK 的内置 API，比如 StringBuffer，Vector 等。你在使用这些类的时候，也许根本不会考虑这些对象到底内部是如何实现的。比如，你很有可能在一个不可能存在并发竞争的场合使用 Vector。而众所周知，Vector 内部使用了 synchronized 请求锁。比如下面的代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] createStrings()&#123;</span><br><span class="line">        Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            v.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v.toArray(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量 v 显然没有逃出 createStrings（）函数之外。以次为基础，虚拟机才可以大胆地将 v 内部的加锁操作去除。如果 createStringso（）返回的不是 String 数组，而是 v 本身，那么就认为变量 v 逃逸出了当前函数，也就是说 v 有可能被其他线程访问。如果是这样，虚拟机就不能消除 v 中的锁操作。<p></p></li></ol><h1 id="threadlocal"><a class="anchor" href="#threadlocal">#</a> ThreadLocal</h1><p>除了控制资源的访问外，我们还可以通过增加资源来保证所有对象的线程安全。从 ThreadLocal 的名字上可以看到，这是一个线程的局部变量。也就是说，只有当前线程可以访问。既然是只有当前线程可以访问的数据，自然是线程安全的。</p><h2 id="threadlocal的实现原理"><a class="anchor" href="#threadlocal的实现原理">#</a> ThreadLocal 的实现原理</h2><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>在 set 时，首先获得当前线程对象，然后通过 getMap () 拿到线程的 ThreadLocalMap，并将值设入 ThreadLocalMap 中。而 ThreadLocalMap 可以理解为一个 Map（虽然不是，但是你可以把它简单地理解成 HashMap），但是它是定义在 Thread 内部的成员。注意下面的定义是从 Thread 类中摘出来的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><br>而设置到 ThreadLocal 中的数据，也正是写入了 threadLocals 这个 Map。其中，key 为 ThreadLocal 当前对象，value 就是我们需要的值。而 threadLocals 本身就保存了当前自己所在线程的所有 “局部变量”，也就是一个 ThreadLocal 变量的集。<p></p><p>在进行 get（）操作时，自然就是将这个 Map 中的数据拿出来：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>首先，get () 方法也是先取得当前线程的 ThreadLocalMap 对象。然后，通过将自己作为 key 取得内部的实际数据。在了解了 ThreadLocal 的内部实现后，我们自然会引出一个问题。那就是这些变量是维护在 Thread 类内部的（ThreadLocalMap 定义所在类），这也意味着只要线程不退出，对象的引用将一直存在。<p></p><p>此时，如果你希望及时回收对象，最好使用 ThreadLocal.remove0 方法将这个变量移除。就像我们习惯性地关闭数据库连接一样。如果你确实不需要这个对象了，那么就应该告诉虚拟机，请把它回收掉，防止内存泄露。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="无锁"><a class="anchor" href="#无锁">#</a> 无锁</h1><p>对于并发控制而言，锁是一种悲观的策略。它总是假设每一次的临界区操作会产生冲突，因此，必须对每次操作都小心翼翼。如果有多个线程同时需要访问临界区资源，就宁可牺牲性能让线程进行等待，所以说锁会阻塞线程执行。而无锁是一种乐观的策略，它会假设对资源的访问是没有冲突的。既然没有冲突，自然不需要等待，所以所有的线程都可以在不停顿的状态下持续执行。那遇到冲突怎么办呢？<br>无锁的策略使用一种叫做比较交换的技术 <code>(CAS Compare And Swap）</code> 来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。</p><h2 id="cas"><a class="anchor" href="#cas">#</a> CAS</h2><ul><li><p>与锁相比，使用比较交换（下文简称 CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。</p></li><li><p>CAS 算法的过程是这样：它包含三个参数 CAS（V，E，N），V 表示要更新的变量，E 表示预期值，N 表示新值。仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。CAS 操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p></li></ul><h1 id="死锁哲学家就餐问题"><a class="anchor" href="#死锁哲学家就餐问题">#</a> 死锁（哲学家就餐问题）</h1><p>如果想避免死锁，除了使用无锁的函数外，另外一种有效的做法是使用第三章节介绍的重入锁，通过重入锁的中断或者限时等待可以有效规避死锁带来的问题。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">Edited on</span> <time title="Modified: 2020-10-31 20:50:32" itemprop="dateModified" datetime="2020-10-31T20:50:32+08:00">2020-10-31</time> </span><span id="computer-science/java/course-3/week-4/" class="item leancloud_visitors" data-flag-title="第4章 锁的优化及注意事项" title="Views"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">Views</span> <span class="leancloud-visitors-count"></span> <span class="text">times</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="MYF WeChat Pay"><p>WeChat Pay</p></div><div><img data-src="/images/alipay.png" alt="MYF Alipay"><p>Alipay</p></div><div><img data-src="/images/paypal.png" alt="MYF PayPal"><p>PayPal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>MYF <i class="ic i-at"><em>@</em></i>一只猫</li><li class="link"><strong>Post link: </strong><a href="https://maoyifan.github.io/computer-science/java/course-3/week-4/" title="第4章 锁的优化及注意事项">https://maoyifan.github.io/computer-science/java/course-3/week-4/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.</li></ul></div></footer></article></div><div class="nav"><div class="item left"><a href="/computer-science/java/course-3/week-2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclfw2t96j20zk0m8x6p.jpg" title="第2章  Java并行程序基础"><span class="type">Previous Post</span> <span class="category"><i class="ic i-flag"></i> Java高并发程序设计</span><h3>第2章 Java并行程序基础</h3></a></div><div class="item right"><a href="/computer-science/java/course-3/week-3/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="第3章 JDK并发包 Java.util.concurrent."><span class="type">Next Post</span> <span class="category"><i class="ic i-flag"></i> Java高并发程序设计</span><h3>第3章 JDK并发包 Java.util.concurrent.</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%8F%90%E9%AB%98%E9%94%81%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">有助于提高 “锁” 性能的几点建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E9%94%81%E4%BC%98%E5%8C%96%E6%89%80%E5%81%9A%E7%9A%84%E5%8A%AA%E5%8A%9B"><span class="toc-number">2.</span> <span class="toc-text">Java 虚拟机对锁优化所做的努力</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#threadlocal"><span class="toc-number">3.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">ThreadLocal 的实现原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cas"><span class="toc-number">4.1.</span> <span class="toc-text">CAS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">死锁（哲学家就餐问题）</span></a></li></ol></div><div class="related panel pjax" data-title="Related"><ul><li><a href="/computer-science/java/course-3/week-1/" rel="bookmark" title="第1章 走入并行世界">第1章 走入并行世界</a></li><li><a href="/computer-science/java/course-3/week-2/" rel="bookmark" title="第2章  Java并行程序基础">第2章 Java并行程序基础</a></li><li><a href="/computer-science/java/course-3/week-3/" rel="bookmark" title="第3章 JDK并发包 Java.util.concurrent.">第3章 JDK并发包 Java.util.concurrent.</a></li><li class="active"><a href="/computer-science/java/course-3/week-4/" rel="bookmark" title="第4章 锁的优化及注意事项">第4章 锁的优化及注意事项</a></li><li><a href="/computer-science/java/course-3/week-5/" rel="bookmark" title="第5章 并行模式与算法">第5章 并行模式与算法</a></li></ul></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="MYF" data-src="/images/avatar.jpg"><p class="name" itemprop="name">MYF</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">28</span> <span class="name">posts</span></a></div><div class="item categories"><a href="/categories/"><span class="count">16</span> <span class="name">categories</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hb3lpZmFu" title="https:&#x2F;&#x2F;github.com&#x2F;maoyifan"><i class="ic i-github"></i></span> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/java/course-3/week-2/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/java/course-3/week-3/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-3/" title="In Java高并发程序设计">Java高并发程序设计</a></div><span><a href="/computer-science/java/course-3/week-2/" title="第2章  Java并行程序基础">第2章 Java并行程序基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-2/" title="In 深入理解Java虚拟机">深入理解Java虚拟机</a></div><span><a href="/computer-science/java/course-2/week-7/" title="第七章 常见面试题总结">第七章 常见面试题总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-7/" title="In 现代操作系统">现代操作系统</a></div><span><a href="/computer-science/java/course-7/week-1/" title="第1周 计算">第1周 计算</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-13/" title="In SpringCloud框架">SpringCloud框架</a></div><span><a href="/computer-science/java/course-13/week-1/" title="第1周 计算">第1周 计算</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-12/" title="In SpringBOOT框架">SpringBOOT框架</a></div><span><a href="/computer-science/java/course-12/week-1/" title="第1周 计算">第1周 计算</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-2/" title="In 深入理解Java虚拟机">深入理解Java虚拟机</a></div><span><a href="/computer-science/java/course-2/week-2/" title="第二章 Java内存区域与内存溢出异常">第二章 Java内存区域与内存溢出异常</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-11/" title="In SpringMVC框架">SpringMVC框架</a></div><span><a href="/computer-science/java/course-11/week-1/" title="第1周 计算">第1周 计算</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/LeetCode/" title="LeetCode 每日一题">LeetCode 每日一题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-3/" title="In Java高并发程序设计">Java高并发程序设计</a></div><span><a href="/computer-science/java/course-3/week-4/" title="第4章 锁的优化及注意事项">第4章 锁的优化及注意事项</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="In 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="In Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/course-2/" title="In 深入理解Java虚拟机">深入理解Java虚拟机</a></div><span><a href="/computer-science/java/course-2/week-3/" title="第三章 垃圾收集器与内存分配">第三章 垃圾收集器与内存分配</a></span></li></ul></div><div><h2>Recent Comments</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">MYF @ MYF</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/java/course-3/week-4/",favicon:{show:"（●´3｀●）Goooood",hide:"(´Д｀)Booooom"},search:{placeholder:"Search for Posts",empty:"We didn't find any results for the search: ${query}",stats:"${hits} results found in ${time} ms"},valine:!0,fancybox:!0,copyright:'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.3"></script></body></html>