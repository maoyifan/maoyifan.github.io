{
    "version": "https://jsonfeed.org/version/1",
    "title": "一只猫",
    "subtitle": "CAT&DOG",
    "icon": "https://maoyifan.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://maoyifan.github.io",
    "items": [
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-16/%E7%AE%80%E5%8D%95/",
            "url": "https://maoyifan.github.io/computer-science/java/course-16/%E7%AE%80%E5%8D%95/",
            "title": "剑指OFFER-简单",
            "date_published": "2020-11-12T08:59:25.000Z",
            "content_html": "<p>:::note info<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXNldC9sY29mLz9kaWZmaWN1bHR5PSVFNyVBRSU4MCVFNSU4RCU5NQ==\">https://leetcode-cn.com/problemset/lcof/?difficulty = 简单</span><br />\n:::</p>\n<h1 id=\"剑指-offer-03-数组中重复的数字\"><a class=\"anchor\" href=\"#剑指-offer-03-数组中重复的数字\">#</a> 剑指 Offer 03. 数组中重复的数字</h1>\n<p><code>题目描述</code> <br />\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">找出数组中重复的数字。</span><br><span class=\"line\">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：</span><br><span class=\"line\">[2, 3, 1, 0, 2, 5, 3]</span><br><span class=\"line\">输出：2 或 3 </span><br></pre></td></tr></table></figure><br />\n·<br />\n <code>利用hashset数据结构的特点</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> repeat = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.add(num)) &#123;</span><br><span class=\"line\">                repeat = num;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> repeat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2</code> <strong> 利用排序数组查找</strong><br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findRepeatNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> repeat = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] clonenums = nums.clone();</span><br><span class=\"line\">        Arrays.sort(clonenums);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(clonenums[i] == clonenums[i-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                repeat = clonenums[i];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> repeat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-05-替换空格\"><a class=\"anchor\" href=\"#剑指-offer-05-替换空格\">#</a> 剑指 Offer 05. 替换空格</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class=\"line\">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure><br />\n <code>题解1：使用自带的函数replace（）</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        String ss = s.replace(<span class=\"string\">&quot; &quot;</span>,<span class=\"string\">&quot;%20&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ss;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>leetcode题解</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[length * <span class=\"number\">3</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> c = s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">                array[size++] = <span class=\"string\">&#x27;%&#x27;</span>;</span><br><span class=\"line\">                array[size++] = <span class=\"string\">&#x27;2&#x27;</span>;</span><br><span class=\"line\">                array[size++] = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                array[size++] = c;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String newStr = <span class=\"keyword\">new</span> String(array, <span class=\"number\">0</span>, size);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">replaceSpace</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder res = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Character c : s.toCharArray())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c == <span class=\"string\">&#x27; &#x27;</span>) res.append(<span class=\"string\">&quot;%20&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> res.append(c);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-06-从尾到头打印链表\"><a class=\"anchor\" href=\"#剑指-offer-06-从尾到头打印链表\">#</a> 剑指 Offer 06. 从尾到头打印链表</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：head &#x3D; [1,3,2]</span><br><span class=\"line\">输出：[2,3,1]</span><br></pre></td></tr></table></figure></p>\n<p><code>题解1</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class=\"line\">        ListNode temp = head;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(temp != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            list.add(temp.val);</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = list.size()-<span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            res[j++] = list.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2 可用**反转链表**或者**栈**</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class=\"line\">        Stack&lt;ListNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;ListNode&gt;();</span><br><span class=\"line\">        ListNode temp = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (temp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            stack.push(temp);</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = stack.size();</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] print = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[size];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            print[i] = stack.pop().val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> print;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-09-用两个栈实现队列\"><a class=\"anchor\" href=\"#剑指-offer-09-用两个栈实现队列\">#</a> 剑指 Offer 09. 用两个栈实现队列</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class=\"line\">[[],[3],[],[]]</span><br><span class=\"line\">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CQueue</span> </span>&#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack1;</span><br><span class=\"line\">    Stack&lt;Integer&gt; stack2;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stack1 = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">        stack2 = <span class=\"keyword\">new</span> Stack&lt;Integer&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        stack1.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stack2.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stack1.isEmpty())&#123;</span><br><span class=\"line\">                stack2.push(stack1.pop());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stack2.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> stack2.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-10-i-斐波那契数列\"><a class=\"anchor\" href=\"#剑指-offer-10-i-斐波那契数列\">#</a> 剑指 Offer 10- I. 斐波那契数列</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class=\"line\">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class=\"line\">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class=\"line\">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class=\"line\">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k =<span class=\"number\">0</span>; k &lt; n-<span class=\"number\">1</span>; k++)&#123;</span><br><span class=\"line\">            res =( i + j) % <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">            i = j;</span><br><span class=\"line\">            j = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-10-ii-青蛙跳台阶问题\"><a class=\"anchor\" href=\"#剑指-offer-10-ii-青蛙跳台阶问题\">#</a> 剑指 Offer 10- II. 青蛙跳台阶问题</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class=\"line\"></span><br><span class=\"line\">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：n &#x3D; 2</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：n &#x3D; 7</span><br><span class=\"line\">输出：21</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：n &#x3D; 0</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">numWays</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n - <span class=\"number\">2</span> ; k++)&#123;</span><br><span class=\"line\">            res = (i + j) % <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">            i = j;</span><br><span class=\"line\">            j = res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-11-旋转数组的最小数字\"><a class=\"anchor\" href=\"#剑指-offer-11-旋转数组的最小数字\">#</a> 剑指 Offer 11. 旋转数组的最小数字</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：[3,4,5,1,2]</span><br><span class=\"line\">输出：1</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：[2,2,2,0,1]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numbers.length - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(numbers[i] &gt; numbers[i+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> numbers[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        Arrays.sort(numbers);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解3 二分法</code></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = numbers.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start &lt; end)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> privot = start + (end - start)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(numbers[privot] &gt; numbers[end])&#123;</span><br><span class=\"line\">                start = privot + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[privot] &lt; numbers[end])&#123;</span><br><span class=\"line\">                end = privot;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                end = end - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[end];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-15-二进制中1的个数\"><a class=\"anchor\" href=\"#剑指-offer-15-二进制中1的个数\">#</a> 剑指 Offer 15. 二进制中 1 的个数</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：00000000000000000000000000001011</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n !=<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            n &amp;= n-<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// you need to treat n as an unsigned value</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n !=<span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">            count += n &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">            n &gt;&gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-17-打印从1到最大的n位数\"><a class=\"anchor\" href=\"#剑指-offer-17-打印从1到最大的n位数\">#</a> 剑指 Offer 17. 打印从 1 到最大的 n 位数</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: n &#x3D; 1</span><br><span class=\"line\">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n <code>未考虑大数问题</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] printNumbers(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        count =(<span class=\"keyword\">int</span>) Math.pow(<span class=\"number\">10.0</span>,n);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[count-<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; count ; i++)&#123;</span><br><span class=\"line\">            res[i-<span class=\"number\">1</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-18-删除链表的节点\"><a class=\"anchor\" href=\"#剑指-offer-18-删除链表的节点\">#</a> 剑指 Offer 18. 删除链表的节点</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</span><br><span class=\"line\">返回删除后的链表的头节点。</span><br><span class=\"line\">注意：此题对比原题有改动</span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class=\"line\">输出: [4,1,9]</span><br><span class=\"line\">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head.val== val)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        newHead= head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (newHead.next.val != val)&#123;</span><br><span class=\"line\">            newHead = newHead.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newHead.next = newHead.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-21-调整数组顺序使奇数位于偶数前面\"><a class=\"anchor\" href=\"#剑指-offer-21-调整数组顺序使奇数位于偶数前面\">#</a> 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</span><br><span class=\"line\">输入：nums &#x3D; [1,2,3,4]</span><br><span class=\"line\">输出：[1,3,2,4] </span><br><span class=\"line\">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] exchange(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start &lt; end)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>((nums[start] % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &amp;&amp; (start &lt; end ))&#123;</span><br><span class=\"line\">                start++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             <span class=\"keyword\">while</span>((nums[end] % <span class=\"number\">2</span> == <span class=\"number\">0</span>) &amp;&amp; (start &lt; end))&#123;</span><br><span class=\"line\">                end--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(nums,start,end);</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-22-链表中倒数第k个节点\"><a class=\"anchor\" href=\"#剑指-offer-22-链表中倒数第k个节点\">#</a> 剑指 Offer 22. 链表中倒数第 k 个节点</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</span><br><span class=\"line\">示例：</span><br><span class=\"line\">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class=\"line\">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getKthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span> || k == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ListNode pAhead = head;</span><br><span class=\"line\">            ListNode pBhead = head;</span><br><span class=\"line\">            <span class=\"comment\">//先让A指针走K-1步</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; k - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pAhead.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                   pAhead = pAhead.next;  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (pAhead.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                pAhead = pAhead.next;</span><br><span class=\"line\">                pBhead = pBhead.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pBhead;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-24-反转链表\"><a class=\"anchor\" href=\"#剑指-offer-24-反转链表\">#</a> 剑指 Offer 24. 反转链表</h1>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (head== <span class=\"keyword\">null</span> || head.next == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//定义一个辅助的指针（变量），帮助我们遍历原来的链表</span></span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        ListNode next = <span class=\"keyword\">null</span>;<span class=\"comment\">//指向当前[cur]节点的下一个节点</span></span><br><span class=\"line\">        ListNode reverseHead = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            next = cur.next;<span class=\"comment\">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class=\"line\">            cur.next = reverseHead.next;<span class=\"comment\">//将当前链表的头节点后的第一个节点作为新加入节点的next</span></span><br><span class=\"line\">            reverseHead.next = cur;<span class=\"comment\">//将新加入的节点作为当前链表的头节点的next的节点</span></span><br><span class=\"line\">            cur = next;<span class=\"comment\">//将原来链表已经移除的节点的下一个节点给到准备移除的节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = reverseHead.next;<span class=\"comment\">//反转完成后将新链表的头节点下一个交个原来链表的头节点的下一个完成反</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-25-合并两个排序的链表\"><a class=\"anchor\" href=\"#剑指-offer-25-合并两个排序的链表\">#</a> 剑指 Offer 25. 合并两个排序的链表</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</span><br><span class=\"line\"></span><br><span class=\"line\">示例1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class=\"line\">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode prehead = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);<span class=\"comment\">//头节点不能动</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode prev = prehead;<span class=\"comment\">//用prev执行头节点的功能</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> &amp;&amp; l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class=\"line\">                prev.next = l1;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prev.next = l2;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            prev = prev.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class=\"line\">        prev.next = l1 == <span class=\"keyword\">null</span> ? l2 : l1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> prehead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-27-二叉树的镜像\"><a class=\"anchor\" href=\"#剑指-offer-27-二叉树的镜像\">#</a> 剑指 Offer 27. 二叉树的镜像</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请完成一个函数，输入一个二叉树，该函数输出它的镜像。</span><br><span class=\"line\"></span><br><span class=\"line\">例如输入：</span><br><span class=\"line\"></span><br><span class=\"line\">     4</span><br><span class=\"line\">   &#x2F;   \\</span><br><span class=\"line\">  2     7</span><br><span class=\"line\"> &#x2F; \\   &#x2F; \\</span><br><span class=\"line\">1   3 6   9</span><br><span class=\"line\">镜像输出：</span><br><span class=\"line\"></span><br><span class=\"line\">     4</span><br><span class=\"line\">   &#x2F;   \\</span><br><span class=\"line\">  7     2</span><br><span class=\"line\"> &#x2F; \\   &#x2F; \\</span><br><span class=\"line\">9   6 3   1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><code>题解1 辅助栈</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stack.add(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.right != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                stack.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//交换当前节点的左右子节点</span></span><br><span class=\"line\">            TreeNode temp = node.left;</span><br><span class=\"line\">            node.left = node.right;</span><br><span class=\"line\">            node.right = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>题解2 递归</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode leftRoot = mirrorTree(root.right);</span><br><span class=\"line\">        TreeNode rightRoot = mirrorTree(root.left);</span><br><span class=\"line\">        root.left = leftRoot;</span><br><span class=\"line\">        root.right = rightRoot;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"剑指-offer-28-对称的二叉树\"><a class=\"anchor\" href=\"#剑指-offer-28-对称的二叉树\">#</a> 剑指 Offer 28. 对称的二叉树</h1>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</span><br><span class=\"line\"></span><br><span class=\"line\">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class=\"line\"></span><br><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\"> &#x2F; \\ &#x2F; \\</span><br><span class=\"line\">3  4 4  3</span><br><span class=\"line\">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class=\"line\"></span><br><span class=\"line\">    1</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\">   \\   \\</span><br><span class=\"line\">   3    3</span><br><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：root &#x3D; [1,2,2,3,4,4,3]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root == <span class=\"keyword\">null</span> ? <span class=\"keyword\">true</span> : recur(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">recur</span><span class=\"params\">(TreeNode L, TreeNode R)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L == <span class=\"keyword\">null</span> &amp;&amp; R == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L == <span class=\"keyword\">null</span> || R == <span class=\"keyword\">null</span> || L.val != R.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://maoyifan.github.io/LeetCode/",
            "url": "https://maoyifan.github.io/LeetCode/",
            "title": "LeetCode 每日一题",
            "date_published": "2020-11-05T04:14:37.000Z",
            "content_html": "<h1 id=\"每日一题-2020-11-13\"><a class=\"anchor\" href=\"#每日一题-2020-11-13\">#</a> 每日一题 2020-11-13</h1>\n<ol start=\"328\">\n<li>奇偶链表 <code>中等</code> <br />\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</span><br><span class=\"line\">请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class=\"line\">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class=\"line\">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br><span class=\"line\">说明:</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">oddEvenList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode p1 = head;</span><br><span class=\"line\">        ListNode p2 = head.next;</span><br><span class=\"line\">        ListNode even = p2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p2 != <span class=\"keyword\">null</span> &amp;&amp; p2.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            p1.next = p2.next;</span><br><span class=\"line\">            p1 = p2.next;</span><br><span class=\"line\">            p2.next = p1.next;</span><br><span class=\"line\">            p2 = p1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p1.next = even;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"每日一题-2020-11-12-2\"><a class=\"anchor\" href=\"#每日一题-2020-11-12-2\">#</a> 每日一题 2020-11-12-2</h1>\n<ol start=\"581\">\n<li>最短无序连续子数组 <code>中等</code> <br />\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</span><br><span class=\"line\">你找到的子数组应是最短的，请输出它的长度。</span><br><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">思路：我们将数组 numsnums 进行排序，记为 nums\\_sortednums_sorted 。然后我们比较 numsnums 和 nums\\_sortednums_sorted 的元素来决定最左边和最右边不匹配的元素。它们之间的子数组就是要求的最短无序子数组。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n <code>题解</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findUnsortedSubarray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] clonenums = nums.clone();</span><br><span class=\"line\">        Arrays.sort(clonenums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> start = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> end = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] != clonenums[i])&#123;</span><br><span class=\"line\">                start = Math.min(i,start);</span><br><span class=\"line\">                end = Math.max(end,i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((end - start) &gt;= <span class=\"number\">0</span> ? end-start+<span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"每日一题-2020-11-12\"><a class=\"anchor\" href=\"#每日一题-2020-11-12\">#</a> 每日一题 2020-11-12</h1>\n<ol start=\"922\">\n<li>按奇偶排序数组 II <code>简单</code> <br />\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</span><br><span class=\"line\">你可以返回任何满足上述条件的数组作为答案。</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：</span><br><span class=\"line\">输入：[4,2,5,7]</span><br><span class=\"line\">输出：[4,5,2,7]</span><br><span class=\"line\">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure><br />\n <code>题解1</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortArrayByParityII(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[A.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> evenIdx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> oddIdx = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; A.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((A[i] &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                ans[oddIdx] = A[i];</span><br><span class=\"line\">                oddIdx += <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ans[evenIdx] = A[i];</span><br><span class=\"line\">                evenIdx += <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//思路为所有的偶数找到正确的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortArrayByParityII(<span class=\"keyword\">int</span>[] A) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = A.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i += <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((A[i] &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>)&#123;<span class=\"comment\">//需要寻找偶数</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>((A[j] &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>)&#123;<span class=\"comment\">//奇数位置上为奇数，正确，寻找下一个奇数位置上为偶数的交换</span></span><br><span class=\"line\">                    j += <span class=\"number\">2</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                swap(A,i,j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] A, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = A[i];</span><br><span class=\"line\">        A[i] = A[j];</span><br><span class=\"line\">        A[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"每日一题-2020-11-11-补\"><a class=\"anchor\" href=\"#每日一题-2020-11-11-补\">#</a> 每日一题 2020-11-11 补</h1>\n<ol start=\"514\">\n<li>自由之路  <code>困难</code> <br />\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</span><br><span class=\"line\"></span><br><span class=\"line\">给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。</span><br><span class=\"line\"></span><br><span class=\"line\">最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。</span><br><span class=\"line\"></span><br><span class=\"line\">旋转 ring 拼出 key 字符 key[i] 的阶段中：</span><br><span class=\"line\"></span><br><span class=\"line\">您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。</span><br><span class=\"line\">如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。</span><br><span class=\"line\">示例</span><br><span class=\"line\">输入: ring &#x3D; &quot;godding&quot;, key &#x3D; &quot;gd&quot;</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释:</span><br><span class=\"line\"> 对于 key 的第一个字符 &#39;g&#39;，已经在正确的位置, 我们只需要1步来拼写这个字符。 </span><br><span class=\"line\"> 对于 key 的第二个字符 &#39;d&#39;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。</span><br><span class=\"line\"> 当然, 我们还需要1步进行拼写。</span><br><span class=\"line\"> 因此最终的输出是 4。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findRotateSteps</span><span class=\"params\">(String ring, String key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = ring.length(), m = key.length();</span><br><span class=\"line\">        List&lt;Integer&gt;[] pos = <span class=\"keyword\">new</span> List[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; ++i) &#123;</span><br><span class=\"line\">            pos[i] = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            pos[ring.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>].add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            Arrays.fill(dp[i], <span class=\"number\">0x3f3f3f</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i : pos[key.charAt(<span class=\"number\">0</span>) - <span class=\"string\">&#x27;a&#x27;</span>]) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = Math.min(i, n - i) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; m; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j : pos[key.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k : pos[key.charAt(i - <span class=\"number\">1</span>) - <span class=\"string\">&#x27;a&#x27;</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class=\"number\">1</span>][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.stream(dp[m - <span class=\"number\">1</span>]).min().getAsInt();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"每日一题-2020-11-10\"><a class=\"anchor\" href=\"#每日一题-2020-11-10\">#</a> 每日一题 2020-11-10</h1>\n<ol start=\"31\">\n<li>下一个排列<br />\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span><br><span class=\"line\"></span><br><span class=\"line\">如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span><br><span class=\"line\"></span><br><span class=\"line\">必须原地修改，只允许使用额外常数空间。</span><br><span class=\"line\"></span><br><span class=\"line\">以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</span><br><span class=\"line\">1,2,3 → 1,3,2</span><br><span class=\"line\">3,2,1 → 1,2,3</span><br><span class=\"line\">1,1,5 → 1,5,1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n <code>题解</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = nums.length - <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">            i--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            swap(nums, i, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reverse(nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = start, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            swap(nums, left, right);</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"每日一题-2020-11-09\"><a class=\"anchor\" href=\"#每日一题-2020-11-09\">#</a> 每日一题 2020-11-09</h1>\n<ol start=\"973\">\n<li>最接近原点的 K 个点 <code>中等</code> <br />\n我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。（这里，平面上两点之间的距离是欧几里德距离。）你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\">输入：points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class=\"line\">输出：[[-2,2]]</span><br><span class=\"line\">解释： </span><br><span class=\"line\">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class=\"line\">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class=\"line\">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class=\"line\">我们只需要距离原点最近的 K &#x3D; 1 个点，所以答案就是 [[-2,2]]。</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\">输入：points &#x3D; [[3,3],[5,-1],[-2,4]], K &#x3D; 2</span><br><span class=\"line\">输出：[[3,3],[-2,4]]</span><br><span class=\"line\">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n <code>题解</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] kClosest(<span class=\"keyword\">int</span>[][] points, <span class=\"keyword\">int</span> K) &#123;</span><br><span class=\"line\">        Arrays.sort(points,<span class=\"keyword\">new</span> Comparator&lt;<span class=\"keyword\">int</span>[]&gt;()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span>[] point1,<span class=\"keyword\">int</span>[] point2)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((point1[<span class=\"number\">0</span>]*point1[<span class=\"number\">0</span>] + point1[<span class=\"number\">1</span>]*point1[<span class=\"number\">1</span>]-(point2[<span class=\"number\">0</span>]*point2[<span class=\"number\">0</span>] + point2[<span class=\"number\">1</span>]*point2[<span class=\"number\">1</span>])));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Arrays.copyOfRange(points,<span class=\"number\">0</span>,K);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2</code> <br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">思路：优先队列</span><br><span class=\"line\">首先我们将前 KK 个点的编号（为了方便最后直接得到答案）以及对应的距离平方放入优先队列中，随后从第K+1个点开始遍历：如果当前点的距离平方比堆顶的点的距离平方要小，就把堆顶的点弹出，再插入当前的点。当遍历完成后，所有在优先队列中的点就是前 K个距离最小的点</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] kClosest(<span class=\"keyword\">int</span>[][] points, <span class=\"keyword\">int</span> K) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;<span class=\"keyword\">int</span>[]&gt; pq = <span class=\"keyword\">new</span> PriorityQueue&lt;<span class=\"keyword\">int</span>[]&gt;(<span class=\"keyword\">new</span> Comparator&lt;<span class=\"keyword\">int</span>[]&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array1, <span class=\"keyword\">int</span>[] array2)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> array2[<span class=\"number\">0</span>] - array1[<span class=\"number\">0</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; K; ++i) &#123;</span><br><span class=\"line\">            pq.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;points[i][<span class=\"number\">0</span>] * points[i][<span class=\"number\">0</span>] + points[i][<span class=\"number\">1</span>] * points[i][<span class=\"number\">1</span>], i&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = points.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = K; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> dist = points[i][<span class=\"number\">0</span>] * points[i][<span class=\"number\">0</span>] + points[i][<span class=\"number\">1</span>] * points[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist &lt; pq.peek()[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">                pq.poll();</span><br><span class=\"line\">                pq.offer(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;dist, i&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] ans = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[K][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; K; ++i) &#123;</span><br><span class=\"line\">            ans[i] = points[pq.poll()[<span class=\"number\">1</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"每日一题-2020-11-08\"><a class=\"anchor\" href=\"#每日一题-2020-11-08\">#</a> 每日一题 2020-11-08</h1>\n<ol start=\"122\">\n<li>买卖股票的最佳时机 II <code>简单</code> <br />\n给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</li>\n</ol>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1:</span><br><span class=\"line\">输入: [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br><span class=\"line\">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class=\"line\">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 2:</span><br><span class=\"line\">输入: [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class=\"line\">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class=\"line\">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 3:</span><br><span class=\"line\">输入: [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"keyword\">int</span>[] prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> prifit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(prices[i] - prices[i-<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                prifit += prices[i] - prices[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prifit;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"每日一题-2020-11-06\"><a class=\"anchor\" href=\"#每日一题-2020-11-06\">#</a> 每日一题 2020-11-06</h1>\n<ol start=\"1356\">\n<li>根据数字二进制下 1 的数目排序 <code>简单</code> <br />\n给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。请你返回排序后的数组。<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]</span><br><span class=\"line\">输出：[0,1,2,4,8,3,5,6,7]</span><br><span class=\"line\">解释：[0] 是唯一一个有 0 个 1 的数。</span><br><span class=\"line\">[1,2,4,8] 都有 1 个 1 。</span><br><span class=\"line\">[3,5,6] 有 2 个 1 。</span><br><span class=\"line\">[7] 有 3 个 1 。</span><br><span class=\"line\">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]</span><br><span class=\"line\">输出：[1,2,4,8,16,32,64,128,256,512,1024]</span><br><span class=\"line\">解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：arr &#x3D; [10000,10000]</span><br><span class=\"line\">输出：[10000,10000]</span><br><span class=\"line\">示例 4：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：arr &#x3D; [2,3,5,7,11,13,17,19]</span><br><span class=\"line\">输出：[2,3,5,17,7,11,13,19]</span><br></pre></td></tr></table></figure><br />\n <code>题解1-暴力</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortByBits(<span class=\"keyword\">int</span>[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] bit = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10001</span>];</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//统计每个整数的二进制中1的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : arr)&#123;</span><br><span class=\"line\">            list.add(num);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = num;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(num != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                count += num % <span class=\"number\">2</span>;</span><br><span class=\"line\">                num &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            bit[temp] = count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//排序</span></span><br><span class=\"line\">        Collections.sort(list,<span class=\"keyword\">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Integer x,Integer y)</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(bit[x] != bit[y])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> bit[x] - bit[y];<span class=\"comment\">//按照个数升序排序</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> x - y;<span class=\"comment\">//按照实际大小排序</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class=\"line\">            res[i] = list.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>题解2-社区题解</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] sortByBits(<span class=\"keyword\">int</span>[] arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = arr.length;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            根据 1的个数 和 当前数值，存储 每一个数字：</span></span><br><span class=\"line\"><span class=\"comment\">                此处是本题解的精髓：1的个数权值最大，其次是本身的值，方便之后的 还原和排序</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            arr[i] = Integer.bitCount(arr[i]) * <span class=\"number\">100_000</span> + arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            将 存储的数字，还原成最初始的数字，并根据 1的个数 和 当前数值 排序</span></span><br><span class=\"line\"><span class=\"comment\">                </span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Arrays.sort(arr);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            arr[i] %= <span class=\"number\">100_000</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/solution/java-7xing-dai-ma-gao-xiao-jie-jue-by-leetcoder-yo/</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"每日一题-2020-11-05\"><a class=\"anchor\" href=\"#每日一题-2020-11-05\">#</a> 每日一题 2020-11-05</h1>\n<ol start=\"127\">\n<li>单词接龙  <code>中等</code> <br />\n给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每次转换只能改变一个字母。</span><br><span class=\"line\">转换过程中的中间单词必须是字典中的单词。</span><br><span class=\"line\">说明:</span><br><span class=\"line\">如果不存在这样的转换序列，返回 0。</span><br><span class=\"line\">所有单词具有相同的长度。</span><br><span class=\"line\">所有单词只由小写字母组成。</span><br><span class=\"line\">字典中不存在重复的单词。</span><br><span class=\"line\">你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</span><br></pre></td></tr></table></figure><br />\n 示例 1:<br />\n 输入:<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beginWord &#x3D; &quot;hit&quot;,</span><br><span class=\"line\">endWord &#x3D; &quot;cog&quot;,</span><br><span class=\"line\">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">输出: 5</span><br><span class=\"line\">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class=\"line\">     返回它的长度 5。</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例 2:</span><br><span class=\"line\">输入:</span><br><span class=\"line\">beginWord &#x3D; &quot;hit&quot;</span><br><span class=\"line\">endWord &#x3D; &quot;cog&quot;</span><br><span class=\"line\">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">输出: 0</span><br><span class=\"line\">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><br />\n <code>解题思路</code> <strong>广度优先</strong><br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; wordSet = <span class=\"keyword\">new</span> HashSet&lt;&gt;(wordList);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!wordSet.contains(endWord)) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        wordSet.remove(beginWord);</span><br><span class=\"line\">        <span class=\"comment\">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class=\"line\">        Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.offer(beginWord);</span><br><span class=\"line\">        Set&lt;String&gt; visited = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        visited.add(beginWord);</span><br><span class=\"line\">        <span class=\"comment\">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> step = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//广度优先框架</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"comment\">//每一层的个数</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> currentSize = queue.size();</span><br><span class=\"line\">            <span class=\"comment\">//依次遍历队列中的每一个单词，寻找匹配的</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; currentSize; i++)&#123;</span><br><span class=\"line\">                String currentWord = queue.poll();</span><br><span class=\"line\">                <span class=\"comment\">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(changeWordEveryOneLetter(currentWord,endWord,queue,visited,wordSet))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> step+<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//一层遍历完，遍历下一层</span></span><br><span class=\"line\">            step++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">changeWordEveryOneLetter</span><span class=\"params\">(String currentWord, String endWord,Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArray = currentWord.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">//遍历每一给字母，尝试改变是否匹配字典</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; endWord.length(); i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//先保存当前字母，便于恢复</span></span><br><span class=\"line\">            <span class=\"keyword\">char</span> originChar = charArray[i];</span><br><span class=\"line\">            <span class=\"comment\">//尝试把该字母替换为‘a’ - &#x27;z&#x27;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> k = <span class=\"string\">&#x27;a&#x27;</span>; k &lt;= <span class=\"string\">&#x27;z&#x27;</span>; k++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k == originChar)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//替换</span></span><br><span class=\"line\">                charArray[i] = k;</span><br><span class=\"line\">                String nextWord = String.valueOf(charArray);</span><br><span class=\"line\">                <span class=\"comment\">//判断替换后的单词是否在字典中</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(wordSet.contains(nextWord))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(nextWord.equals(endWord))&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//如果该单词没有被访问过，目的是防止成环</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!visited.contains(nextWord))&#123;</span><br><span class=\"line\">                        queue.add(nextWord);</span><br><span class=\"line\">                         <span class=\"comment\">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class=\"line\">                        visited.add(nextWord);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//把该位置的字母恢复</span></span><br><span class=\"line\">            charArray[i] = originChar;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\nMore info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd29yZC1sYWRkZXI=\">Deployment</span><br />\n 链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd29yZC1sYWRkZXIvc29sdXRpb24veWFuLWR1LXlvdS14aWFuLWJpYW4tbGktc2h1YW5nLXhpYW5nLXlhbi1kdS15b3UtMi8=\">https://leetcode-cn.com/problems/word-ladder/solution/yan-du-you-xian-bian-li-shuang-xiang-yan-du-you-2/</span></li>\n</ol>\n<h2 id=\"广度优先相关题\"><a class=\"anchor\" href=\"#广度优先相关题\">#</a> 广度优先相关题</h2>\n<ol>\n<li>\n<p><strong>剑指 Offer 32 - I. 从上到下打印二叉树</strong><br />\n从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">例如:</span><br><span class=\"line\">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回：</span><br><span class=\"line\">[3,9,20,15,7]</span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">            TreeNode node = queue.poll();</span><br><span class=\"line\">            list.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.left != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.right != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[list.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class=\"line\">            res[i] = list.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>二叉树的层序遍历<br />\n给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">示例：</span><br><span class=\"line\">二叉树：[3,9,20,null,null,15,7],</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回其层次遍历结果：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [9,20],</span><br><span class=\"line\">  [15,7]</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = queue.size();</span><br><span class=\"line\">        List&lt;Integer&gt; level = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123; </span><br><span class=\"line\">            TreeNode node = queue.poll();</span><br><span class=\"line\">            level.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><strong>103. 二叉树的锯齿形层次遍历</strong><br />\n给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br />\n例如：<br />\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定二叉树 [3,9,20,null,null,15,7],</span><br><span class=\"line\"></span><br><span class=\"line\">    3</span><br><span class=\"line\">   &#x2F; \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    &#x2F;  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">返回锯齿形层次遍历如下：</span><br><span class=\"line\"></span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [20,9],</span><br><span class=\"line\">  [15,7]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<p><code>题解</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class=\"line\">List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> ArrayDeque&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = queue.size();</span><br><span class=\"line\">        List&lt;Integer&gt; level = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123; </span><br><span class=\"line\">            TreeNode node = queue.poll();</span><br><span class=\"line\">            level.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.add(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queue.add(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.add(level);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ; i &lt; res.size(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span> != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            Collections.reverse(res.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-15/week-1/",
            "url": "https://maoyifan.github.io/computer-science/java/course-15/week-1/",
            "title": "第1章 MySQL体系结构和存储引擎",
            "date_published": "2020-11-02T14:53:25.000Z",
            "content_html": "<p>:::note info<br />\n 来源 https://www.cnblogs.com/yanjieli/p/9780100.html<br />\n:::</p>\n<h1 id=\"mysql体系结构\"><a class=\"anchor\" href=\"#mysql体系结构\">#</a> MySQL 体系结构</h1>\n<p><img data-src=\"/images/i1.1.png\" alt=\"\" /><br />\n连接者：不同语言的代码程序和 mysql 的交互（SQL 交互）</p>\n<ol>\n<li>连接池 管理、缓冲用户的连接，线程处理等需要缓存的需求</li>\n<li>管理服务和工具组件 系统管理和控制工具，例如备份恢复、Mysql 复制、集群等</li>\n<li>sql 接口 接受用户的 SQL 命令，并且返回用户需要查询的结果</li>\n<li>查询解析器 SQL 命令传递到解析器的时候会被解析器验证和解析 (权限、语法结构)</li>\n<li>查询优化器 SQL 语句在查询之前会使用查询优化器对查询进行优化<br />\n <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">id</span>,<span class=\"keyword\">name</span> <span class=\"keyword\">from</span> <span class=\"keyword\">user</span> <span class=\"keyword\">where</span> age = <span class=\"number\">40</span>; </span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>这个 select 查询先根据 where 语句进行选取，而不是先将表全部查询出来以后再进行 age 过滤</li>\n<li>这个 select 查询先根据 id 和 name 进行属性投影，而不是将属性全部取出以后再进行过滤</li>\n<li>将这两个查询条件联接起来生成最终查询结果</li>\n</ul>\n<ol start=\"6\">\n<li>缓存 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据</li>\n<li>插入式存储引擎 存储引擎说白了就是如何管理操作数据（存储数据、如何更新、查询数据等）的一种方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）<br />\nMySql 数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。甚至一个库中不同的表使用不同的存储引擎，这些都是允许的。</li>\n</ol>\n<h1 id=\"存储引擎\"><a class=\"anchor\" href=\"#存储引擎\">#</a> 存储引擎</h1>\n<h2 id=\"myisam存储引擎\"><a class=\"anchor\" href=\"#myisam存储引擎\">#</a> MyISAM 存储引擎</h2>\n<p>由于该存储引擎 <code>不支持事务、也不支持外键，所以访问速度较快</code> 。因此当对事务完整性没有要求并以访问为主的应用适合使用该存储引擎。</p>\n<h2 id=\"innodb存储引擎\"><a class=\"anchor\" href=\"#innodb存储引擎\">#</a> InnoDB 存储引擎</h2>\n<p>mysql 5.5 版本以后默认的存储引擎<br />\n由于该存储引擎在 <code>事务</code> 上具有优势，即支持具有提交、回滚及崩溃恢复能力等事务特性，所以比 MyISAM 存储引擎 <code>占用更多的磁盘空间</code> 。因此当需要频繁的更新、删除操作，同时还对事务的完整性要求较高，需要实现并发控制，建议选择。</p>\n<h2 id=\"memory\"><a class=\"anchor\" href=\"#memory\">#</a> MEMORY</h2>\n<p>MEMORY 存储引擎存储数据的位置是 <code>内存，因此访问速度最快</code> ，但是 <code>安全上没有保障</code> 。适合于需要快速的访问或临时表。</p>\n<h1 id=\"物理文件\"><a class=\"anchor\" href=\"#物理文件\">#</a> 物理文件</h1>\n<p>物理文件包括：日志文件，数据文件，配置文件，pid 文件，socket 文件等</p>\n<h2 id=\"日志文件\"><a class=\"anchor\" href=\"#日志文件\">#</a> 日志文件</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error log  |错误日志    |排错  |&#x2F;var&#x2F;log&#x2F;mysqld.log【默认开启】</span><br><span class=\"line\">bin log    |二进制日志  |备份  增量备份 |DDL DML DCL</span><br><span class=\"line\">Relay log  |中继日志    |复制  接收 |replication master</span><br><span class=\"line\">slow log   |慢查询日志  |调优  |查询时间超过指定值</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"数据库-数据库实例-数据库服务器\"><a class=\"anchor\" href=\"#数据库-数据库实例-数据库服务器\">#</a> 数据库、数据库实例、数据库服务器</h1>\n<h2 id=\"数据库database\"><a class=\"anchor\" href=\"#数据库database\">#</a> 数据库（database）</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库（database）：</span><br><span class=\"line\">操作系统或存储上的数据文件的集合。mysql数据库中，数据库文件可以是* .frm、*.MYD、*.MYI、*.ibd等结尾的文件，</span><br><span class=\"line\">不同存储引擎文件类型不同。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据库实例instance\"><a class=\"anchor\" href=\"#数据库实例instance\">#</a> 数据库实例（instance）</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由后台进程或者线程以及一个共享内存区组成。共享内存可以被运行的后台线程所共享。</span><br><span class=\"line\">需要注意：数据库实例才是真正操作数据库的。</span><br><span class=\"line\">数据库和数据库实例的关系：</span><br><span class=\"line\">通常情况下，数据库实例和数据库是一一对应的关系，也就是一个数据库实例对应一个数据库；</span><br><span class=\"line\">但是，在集群环境中存在多个数据库实例共同使用一个数据库。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据库服务器database-server\"><a class=\"anchor\" href=\"#数据库服务器database-server\">#</a> 数据库服务器 (database server)</h2>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">数据库服务器(database server)：部署安装数据库实例的服务器。</span><br><span class=\"line\">mysql中的逻辑对象:</span><br><span class=\"line\">mysqld_process+memory+datafile|logfile|pidfile...---&gt;库－－＞表－－＞记录（由行与列组成）</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"连接mysql\"><a class=\"anchor\" href=\"#连接mysql\">#</a> 连接 mysql</h1>\n<p>本质为进程间的通信</p>\n<ul>\n<li>管道、</li>\n<li>命名管道和共享内存（同一台服务器）</li>\n<li>TCP/IP 套接字（使用最多，一般客户端和数据库实例不在同一台服务器上使用）</li>\n<li>UNIX 域套接字（客户端和数据库实例在一台服务器上使用该方法）</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "Java",
                "java编程思想"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-15/week-2/",
            "url": "https://maoyifan.github.io/computer-science/java/course-15/week-2/",
            "title": "第2章 InnoDB存储引擎",
            "date_published": "2020-11-01T14:33:45.000Z",
            "content_html": "",
            "tags": [
                "计算机科学",
                "Java",
                "java编程思想"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-16/%E4%B8%AD%E7%AD%89/",
            "url": "https://maoyifan.github.io/computer-science/java/course-16/%E4%B8%AD%E7%AD%89/",
            "title": "第2章 InnoDB存储引擎",
            "date_published": "2020-11-01T14:33:45.000Z",
            "content_html": "",
            "tags": [
                "计算机科学",
                "Java",
                "java编程思想"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-16/%E5%9B%B0%E9%9A%BE/",
            "url": "https://maoyifan.github.io/computer-science/java/course-16/%E5%9B%B0%E9%9A%BE/",
            "title": "第2章 InnoDB存储引擎",
            "date_published": "2020-11-01T14:33:45.000Z",
            "content_html": "",
            "tags": [
                "计算机科学",
                "Java",
                "java编程思想"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-3/week-5/",
            "url": "https://maoyifan.github.io/computer-science/java/course-3/week-5/",
            "title": "第5章 并行模式与算法",
            "date_published": "2020-10-31T12:51:25.000Z",
            "content_html": "<h1 id=\"单例模式\"><a class=\"anchor\" href=\"#单例模式\">#</a> 单例模式</h1>\n<p>单例模式是设计模式中使用最为普遍的模式之一。它是一种对象创建模式，用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。在 Java 中，这样的行为能带来<br />\n两大好处：</p>\n<ul>\n<li>对于频繁使用的对象，可以省略 new 操作花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>\n<li>由于 new 操作的次数减少，因而对系统内存的使用频率也降低，这将减轻 GC 压力，缩短 GC 停顿时间。<br />\n实现方式：</li>\n</ul>\n<ol>\n<li>懒汉式<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 注意：</li>\n</ol>\n<ul>\n<li>把 Singleton 的构造函数设置为 private；</li>\n<li>instance 对象必须是 private 并且 static 的。</li>\n</ul>\n<p><code>不足</code> ：就是 Singleton 构造函数，或者说 Singleton 实例在什么时候创建是不受控制的。对于静态成员 instance，它会在类第一次初始化的时候被创建。这个时刻并不一定是 getInstance）方法第一次被调用的时候。</p>\n<ol start=\"2\">\n<li>饿汉式<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazySingleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">LazySingleton</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> LazySingleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> LazySingleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> LazySingleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 这个 LazySingleton 的核心思想如下：最初，我们并不需要实例化 instance，而当 getInstance () 方法被第一次调用时，创建单例对象。为了防止对象被多次创建，我们不得不使用 synchronized 进行方法同步。这种实现的好处是，充分利用了延迟加载，只在真正需要时创建对象。但坏处也很明显，并发环境下加锁，竞争激烈的场合对性能可能产生一定的影响.</li>\n</ol>\n<p>双重加锁<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getSingleton</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            instance = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 静态内部类<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"不变模式\"><a class=\"anchor\" href=\"#不变模式\">#</a> 不变模式</h1>\n<p>在并行软件开发过程中，同步操作似乎是必不可少的。当多线程对同一个对象进行读写操作时，为了保证对象数据的一致性和正确性，有必要对对象进行同步。而同步操作对系统性能是有相当的损耗。为了能尽可能地去除这些同步操作，提高并行程序性能，可以使用一种不可改变的对象，依靠对象的不变性，可以确保其在没有同步操作的多线程环境中依然始终保持内部状态的一致性和正确性。这就是不变模式。<br />\n不变模式天生就是多线程友好的，它的核心思想是，一个对象一旦被创建，则它的内部状态将永远不会发生改变。所以，没有一个线程可以修改其内部状态和数据，同时其内部状态也绝不会自行发生改变。基于这些特性，对不变对象的多线程操作不需要进行同步控制。<br />\n不变模式的主要使用场景需要满足以下 2 个条件：</p>\n<ul>\n<li>当对象创建后，其内部状态和数据不再发生任何变化。</li>\n<li>对象需要被共享，被多线程频繁访问。<br />\n在 JDK 中，不变模式的应用非常广泛。其中，最为典型的就是 java.lang.String 类。此外，所有的元数据类包装类，都是使用不变模式实现的。主要的不变模式类型如下：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.String </span><br><span class=\"line\">java.lang.Boolean </span><br><span class=\"line\">java.lang.Byte </span><br><span class=\"line\">java.lang.Character </span><br><span class=\"line\">java.lang.Double </span><br><span class=\"line\">java.lang.Float </span><br><span class=\"line\">java.lang.Integer </span><br><span class=\"line\">java.lang.Long</span><br><span class=\"line\">java.lang.Short</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "Java",
                "Java高并发程序设计"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-3/week-3/",
            "url": "https://maoyifan.github.io/computer-science/java/course-3/week-3/",
            "title": "第3章 JDK并发包 Java.util.concurrent.",
            "date_published": "2020-10-31T11:49:25.000Z",
            "content_html": "<h1 id=\"同步控制\"><a class=\"anchor\" href=\"#同步控制\">#</a> 同步控制</h1>\n<h2 id=\"重入锁\"><a class=\"anchor\" href=\"#重入锁\">#</a> 重入锁</h2>\n<p>重入锁可以完全替代 synchronized 关键字。使用 java.util.concurrent.locks.ReentrantLock 类来实现。<br />\n <code>案例</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReenterLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000000</span>; j++) &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ReenterLock t = <span class=\"keyword\">new</span> ReenterLock();</span><br><span class=\"line\">        Thread t1 = <span class=\"keyword\">new</span> Thread(t);</span><br><span class=\"line\">        Thread t2 = <span class=\"keyword\">new</span> Thread(t);</span><br><span class=\"line\">        t1.start();</span><br><span class=\"line\">        t2.start();</span><br><span class=\"line\">        t1.join();</span><br><span class=\"line\">        t2.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>结果:</code> 2000000<br />\n 从类的命名上看，Re-Entrant-Lock 翻译成重入锁也是非常贴切的。因为这种锁是可以反复进入的。反复仅仅局限于一个线程。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000000</span>; j++) &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 如果同一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数。如果释放锁的次数多，那么会得到一个 java.lag.llegalMonitorStateException 异常，反之，如果释放锁的次数少了，那么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。</p>\n<h2 id=\"重入锁的功能\"><a class=\"anchor\" href=\"#重入锁的功能\">#</a> 重入锁的功能</h2>\n<ol>\n<li>中断响应<br />\n对于 synchronized 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就保持等待。而使用重入锁，则提供另外一种可能，那就是线程可以被中断。也就是在等待锁的过程中，程序可以根据需要取消对锁的请求。</li>\n<li>锁申请等待限时<br />\n除了等待外部通知之外，要避免死锁还有另外一种方法，那就是限时等待。<br />\n通常，我们无法判断为什么一个线程迟迟拿不到锁。也许是因为死锁了，也许是因为产生了饥饿。但如果给定一个等待时间，让线程自动放弃，那么对系统来说是有意义的。我们可以使用 tryLock）方法进行一次限时的等待。我们可以使用 <code>tryLock（）</code> 方法进行一次限时的等待。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.tryAcquireNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\nReentrantLock.tyLock）方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回 true。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回 false。这种模式不会引起线程等待，因此也不会产生死锁。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sync.nonfairTryAcquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></li>\n<li>公平锁<br />\n公平锁，会按照时间的先后顺序，保证先到者先得，后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果我们使用 synchronized 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁允许我们对其公平性进行设置。它有一个如下的构造函数：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">       sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>对上面 ReentrantLock 的几个重要方法整理如下。</p>\n<ul>\n<li>lockInterruptibly ()：获得锁，但优先响应中断。</li>\n<li>tryLock ()：尝试获得锁，如果成功，返回 true，失败返回 false。该方法不等待，立即返回。</li>\n<li>tryLock（long time，TimeUnit unit）：在给定时间内尝试获得锁。</li>\n<li>unlock ()：释放锁。</li>\n</ul>\n<h2 id=\"允许多个线程同时访问信号量semaphore\"><a class=\"anchor\" href=\"#允许多个线程同时访问信号量semaphore\">#</a> 允许多个线程同时访问：信号量（Semaphore）</h2>\n<p>无论是内部锁 synchronized 还是重入锁 ReentrantLock，一次都只允许一个线程访问一个资源，而信号量却可以指定多个线程，同时访问某一个资源。信号量主要提供了以下构造函数：</p>\n<h1 id=\"线程池\"><a class=\"anchor\" href=\"#线程池\">#</a> 线程池</h1>\n<h2 id=\"为什么需要线程池\"><a class=\"anchor\" href=\"#为什么需要线程池\">#</a> 为什么需要线程池</h2>\n<ul>\n<li>首先，虽然与进程相比，线程是一种轻量级的工具，但其创建和关闭依然需要花费时间，如果为每一个小的任务都创建一个线程，很有可能出现创建和销毁线程所占用的时间大于该线程真实工作所消耗的时间的情况，反而会得不偿失。</li>\n<li>其次，线程本身也是要占用内存空间的，大量的线程会抢占宝贵的内存资源，如果处理不当，可能会导致 OutofMemory 异常。即便没有，大量的线程回收也会给 GC 带来很大的压力，延长 GC 的停顿时间。</li>\n</ul>\n<h2 id=\"什么是线程池\"><a class=\"anchor\" href=\"#什么是线程池\">#</a> 什么是线程池</h2>\n<p>简而言之，在使用线程池后，创建线程变成了从线程池获得空闲线程，关闭线程变成了向池子归还线程。</p>\n<h2 id=\"jdk对线程池的支持\"><a class=\"anchor\" href=\"#jdk对线程池的支持\">#</a> JDK 对线程池的支持</h2>\n<p>JDK 提供了一套 Executor 框架，其本质就是一个线程池。<br />\nExecutor 框架提供了各种类型的线程池，主要有以下工厂方法：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newSingleThreadScheduledExecutor</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ScheduledExecutorService <span class=\"title\">newScheduledThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>newFixedThreadPool（）方法：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>\n<li>newSingleThreadExecutor () 方法：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>\n<li>newCachedThreadPool（）方法：该方法返回一个可根据实际情况调整线程数量的线程池。<br />\n线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>\n<li>newSingleThreadScheduledExecutor () 方法：该方法返回一个 ScheduledExecutorService 对象，线程池大小为 1.ScheduledExecutorService 接口在 ExecutorService 接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。</li>\n<li>newScheduledThreadPool () 方法：该方法也返回一个 ScheduledExecutorService 对象，但该线程池可以指定线程数量。</li>\n</ul>\n<h2 id=\"核心线程池的内部实现\"><a class=\"anchor\" href=\"#核心线程池的内部实现\">#</a> 核心线程池的内部实现</h2>\n<p>以上几种创建线程池的方法内部均实现了 ThreadPoolExecutor 接口。<br />\n <code>newFixedThreadPool(int nThreads)</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                      <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n <code>newSingleThreadExecutor()</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">           (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                   <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                   <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure><br />\n <code>newCachedThreadPool()</code> <br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                      <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"threadpoolexecutor最重要的构造函数\"><a class=\"anchor\" href=\"#threadpoolexecutor最重要的构造函数\">#</a> ThreadPoolExecutor 最重要的构造函数</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><br />\n 函数参数含义如下：</p>\n<ol>\n<li>corePoolSize：指定了线程池中的线程数量。</li>\n<li>maximumPoolSize：指定了线程池中的最大线程数量。</li>\n<li>keepAliveTime：当线程池线程数量超过 corePoolSize 时，多余的空闲线程的存活时间。即，超过 corePoolsize 的空闲线程，在多长时间内，会被销毁。</li>\n<li>unit：keepAliveTime 的单位。</li>\n<li>workQueue：任务队列，被提交但尚未被执行的任务。</li>\n<li>threadFactory：线程工厂，用于创建线程，一般用默认的即可。</li>\n<li>handler：拒绝策略。当任务太多来不及处理，如何拒绝任务。</li>\n</ol>\n<h3 id=\"workqueue\"><a class=\"anchor\" href=\"#workqueue\">#</a> workQueue</h3>\n<p>参数 workQueue 指被提交但未执行的任务队列，它是一个 BlockingQueue 接口的对象，仅用于存放 Runnable 对象。根据队列功能分类，在 ThreadPoolExecutor 的构造函数中可使用以下几种 BlockingQueue.</p>\n<ul>\n<li><strong>直接提交的队列</strong>：该功能由 <code>SynchronousQueue</code>  对象提供。SynchronousQueue 是一个特殊的 BlockingQueue，SynchronousQueue 没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用 SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的进程，则尝试创建新的进程，如果进程数量已经达到最大值，则执行拒绝策略。因此，使用 SynchronousQueue 队列，通常要设置很大的 maximumPoolSize 值，否则很容易执行拒绝策略。</li>\n<li><strong>有界的任务队列</strong>：有界的任务队列可以使用 <code>ArrayBlockingQueue</code>  实现。ArrayBlockingQueue 的构造函数必须带一个容量参数，表示该队列的最大容量，如下所示。当使用有界的任务队列时，若有新的任务需要执行，如果线程池的实际线程数小于 corePoolsize，则会优先创建新的线程，若大于 corePoolsize，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于 maximumPoolSize 的前提下，创建新的进程执行任务。若大于 maximumPoolsize，则执行拒绝策略。可见，有界队列仅当在任务队列装满时，才可能将线程数提升到 corePoolSize 以上，换言之，除非系统非常繁忙，否则确保核心线程数维持在在 corePoolSize.</li>\n<li><strong>无界的任务队列</strong>：无界任务队列可以通过 <code>LinkedBlockingQueue</code>  类实现。与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于 corePoolSize 时，线程池会生成新的线程执行任务，但当系统的线程数达到 corePoolsize 后，就不会继续增加。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。</li>\n<li><strong>优先任务队列</strong>：优先任务队列是带有执行优先级的队列。它通过 <code>PriorityBlockingQueue</code>  实现，可以控制任务的执行先后顺序。它是一个特殊的无界队列。无论是有界队列 ArrayBlockingQueue，还是未指定大小的无界队列 LinkedBlockingQueue 都是按照先进先出算法处理任务的。而 PriorityBlockingQueue 则可以根据任务自身的优先级顺序先后执行，在确保系统性能的同时，也能有很好的质量保证（总是确保高优先级的任务先执行）。</li>\n</ul>\n<h2 id=\"线程池工作逻辑\"><a class=\"anchor\" href=\"#线程池工作逻辑\">#</a> 线程池工作逻辑</h2>\n<p>ThreadPoolExecutor 线程池的核心调度代码，这段代码也充分体现了上述线程池的工作逻辑：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Proceed in 3 steps:</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class=\"line\"><span class=\"comment\">         * start a new thread with the given command as its first</span></span><br><span class=\"line\"><span class=\"comment\">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class=\"line\"><span class=\"comment\">         * workerCount, and so prevents false alarms that would add</span></span><br><span class=\"line\"><span class=\"comment\">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class=\"line\"><span class=\"comment\">         * to double-check whether we should have added a thread</span></span><br><span class=\"line\"><span class=\"comment\">         * (because existing ones died since last checking) or that</span></span><br><span class=\"line\"><span class=\"comment\">         * the pool shut down since entry into this method. So we</span></span><br><span class=\"line\"><span class=\"comment\">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class=\"line\"><span class=\"comment\">         * stopped, or start a new thread if there are none.</span></span><br><span class=\"line\"><span class=\"comment\">         *</span></span><br><span class=\"line\"><span class=\"comment\">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class=\"line\"><span class=\"comment\">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class=\"line\"><span class=\"comment\">         * and so reject the task.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            c = ctl.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">                reject(command);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 调度逻辑：<br />\n<img data-src=\"/images/c3.1.jpg\" alt=\"\" /></p>\n<h2 id=\"拒绝策略\"><a class=\"anchor\" href=\"#拒绝策略\">#</a> 拒绝策略</h2>\n<p>ThreadPoolExecutor 的最后一个参数指定了拒绝策略。也就是当任务数量超过系统实际承载能力时，该如何处理呢？这时就要用到拒绝策略了。拒绝策略可以说是系统超负荷运行时的补救措施，通常由于压力太大而引起的，也就是线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列中也已经排满了，再也塞不下新任务了。这时，我们就需要有一套机制，合理地处理这个问题。<br />\nJDK 内置提供了四种拒绝策略：</p>\n<ol>\n<li>AbortPolicy 策略：该策略会直接抛出异常，阻止系统正常工作。</li>\n<li>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</li>\n<li>DiscardOledestPolicy 策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>\n<li>DiscardPolicy 策略：该策略默默地丢弃无法处理的任务，不予任何处理。</li>\n</ol>\n<h2 id=\"自定义线程创建threadfactory\"><a class=\"anchor\" href=\"#自定义线程创建threadfactory\">#</a> 自定义线程创建：ThreadFactory</h2>\n<p>ThreadFactory 是一个接口，它只有一个方法，用来创建线程：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ThreadFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Constructs a new &#123;<span class=\"doctag\">@code</span> Thread&#125;.  Implementations may also initialize</span></span><br><span class=\"line\"><span class=\"comment\">     * priority, name, daemon status, &#123;<span class=\"doctag\">@code</span> ThreadGroup&#125;, etc.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> r a runnable to be executed by new thread instance</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> constructed thread, or &#123;<span class=\"doctag\">@code</span> null&#125; if the request to</span></span><br><span class=\"line\"><span class=\"comment\">     *         create a thread is rejected</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">Thread <span class=\"title\">newThread</span><span class=\"params\">(Runnable r)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 当线程池需要新建线程时，就会调用这个方法。</p>\n<h2 id=\"合理的选择优化线程池线程数量\"><a class=\"anchor\" href=\"#合理的选择优化线程池线程数量\">#</a> 合理的选择：优化线程池线程数量</h2>\n<p>一般来说，确定线程池的大小需要考虑 CPU 数量、内存大小等因素。在《Java Concurrency in Practice》一书中给出了一个估算线程池大小的经验公式：<br />\n<img data-src=\"/images/c3.2.jpg\" alt=\"\" /></p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "Java高并发程序设计"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-3/week-4/",
            "url": "https://maoyifan.github.io/computer-science/java/course-3/week-4/",
            "title": "第4章 锁的优化及注意事项",
            "date_published": "2020-10-31T11:49:25.000Z",
            "content_html": "<h1 id=\"有助于提高锁性能的几点建议\"><a class=\"anchor\" href=\"#有助于提高锁性能的几点建议\">#</a> 有助于提高 “锁” 性能的几点建议</h1>\n<p><img data-src=\"/images/c4.1.jpg\" alt=\"\" /></p>\n<ol>\n<li>\n<p>减小锁持有时间<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> synMethod&#123;</span><br><span class=\"line\">        method1();</span><br><span class=\"line\">        method2();</span><br><span class=\"line\">        method3();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\nsynMethod（）方法中，假设只有 method2（）方法是有同步需要的，而 method1 () 和 method3 () 并不需要做同步控制。如果 method1 () 和 method3 () 分别是重量级的方法，则会花费较长的 CPU 时间。此时，如果在并发量较大，使用这种对整个方法做同步的方案，会导致等待线程大量增加。因为一个线程，在进入该方法时获得内部锁，只有在所有任务都执行完后，才会释放锁。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> synMethod2&#123;</span><br><span class=\"line\">        method1();</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        method3();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 一个较为优化的解决方案是，只在必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量。<br />\n <code>注意</code> ：减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力。</p>\n</li>\n<li>\n<p>减小锁粒度<br />\n对于 HashMap 来说，最重要的两个方法就是 get () 和 put ()。一种最自然的想法就是对整个 HashMap 加锁，必然可以得到一个线程安全的对象。但是这样做，我们就认为加锁粒度太大。对于 ConcurrentHashMap，它内部进一步细分了若干个小的 HashMap，称之为段（SEGMENT) 默认情况下，一个 ConcurrentHashMap 被进一步细分为 16 个段。<br />\n如果需要在 ConcurrentHashMap 中增加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该被存放到哪个段中，然后对该段加锁，并完成 put（）操作。在多线程环境中，如果多个线程同时进行 put（）操作，只要被加入的表项不存放在同一个段中，则线程间便可以做到真正的并行。<br />\n <code>缺点</code> <br />\n减少锁粒度会引入一个新的问题，即：当系统需要取得全局锁时，其消耗的资源会比较多。仍然以 ConcurrentHashMap 类为例，虽然其 put）方法很好地分离了锁，但是当试图访问 ConcurrentHashMap 全局信息时，就会需要同时取得所有段的锁方能顺利实施。比如 ConcurrentHashMap 的 size（）方法，它将返回 ConcurrentHashMap 的有效表项的数量，即 ConcurrentHashMap 的全部有效表项之和。要获取这个信息需要取得所有子段的锁.</p>\n</li>\n<li>\n<p>读写分离锁来替换独占锁<br />\n在之前我们已经提过，使用读写锁 ReadWriteLock 可以提高系统的性能。使用读写分离锁来替代独占锁是减小锁粒度的一种特殊情况。如果说上节中提到的减少锁粒度是通过分割数据结构实现的，那么，读写锁则是对系统功能点的分割。<br />\n在读多写少的场合，读写锁对系统性能是很有好处的。因为如果系统在读写数据时均只使用独占锁，那么读操作和写操作间、读操作和读操作间、写操作和写操作间均不能做到真正的并发，并且需要相互等待。而读操作本身不会影响数据的完整性和一致性。因此，理论上讲，在大部分情况下，应该可以允许多线程同时读，读写锁正是实现了这种功能.</p>\n</li>\n<li>\n<p>锁分离<br />\n在 LinkedBlockingQueue 的实现中，take（）函数和 put () 函数分别实现了从队列中取得数据和往队列中增加数据的功能。虽然两个函数都对当前队列进行了修改操作，但由于 LinkedBlockingQueue 是基于链表的，因此，两个操作分别作用于队列的前端和尾端从理论上说，两者并不冲突。<br />\n如果使用独占锁，则要求在两个操作进行时获取当前队列的独占锁，那么 take）和 put（）操作就不可能真正的并发，在运行时，它们会彼此等待对方释放锁资源。在这种情况下，锁竞争会相对比较激烈，从而影响程序在高并发时的性能。因此，在 JDK 的实现中，并没有采用这样的方式，取而代之的是两把不同的锁，分离了 take () 和 put () 操作。</p>\n</li>\n<li>\n<p>锁粗化<br />\n如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化。<br />\n为此，虚拟机在遇到一连串连续地对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化。</p>\n</li>\n</ol>\n<h1 id=\"java虚拟机对锁优化所做的努力\"><a class=\"anchor\" href=\"#java虚拟机对锁优化所做的努力\">#</a> Java 虚拟机对锁优化所做的努力</h1>\n<ol>\n<li>\n<p>锁偏向<br />\n锁偏向是一种针对加锁操作的优化手段。它的 <code>核心思想是</code> ：** 如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。** 这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。这样偏向模式会失效，因此还不如不启用偏向锁。使用 Java 虚拟机参数:-xx：+UseBiasedLocking 可以开启偏向锁。</p>\n</li>\n<li>\n<p>轻量级锁<br />\n如果偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为重量级锁。</p>\n</li>\n<li>\n<p>自旋锁<br />\n锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力 - 一自旋锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在几个 CPU 时钟周期后，就可以得到锁。如果这样，简单粗暴地挂起线程可能是一种得不偿失的操作。因此，系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此，虚拟机会让当前线程做几个空循环（这也是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真实地将线程在操作系统层面挂起。</p>\n</li>\n<li>\n<p>锁消除<br />\n锁消除是一种更彻底的锁优化。Java 虚拟机在 JIT 编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省毫无意义的请求锁时间。<br />\n在 Java 软件开发过程中，我们必然会使用一些 JDK 的内置 API，比如 StringBuffer，Vector 等。你在使用这些类的时候，也许根本不会考虑这些对象到底内部是如何实现的。比如，你很有可能在一个不可能存在并发竞争的场合使用 Vector。而众所周知，Vector 内部使用了 synchronized 请求锁。比如下面的代码：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> String[] createStrings()&#123;</span><br><span class=\"line\">        Vector&lt;String&gt; v = <span class=\"keyword\">new</span> Vector&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">            v.add(Integer.toString(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.toArray(<span class=\"keyword\">new</span> String[]&#123;&#125;);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 锁消除涉及的一项关键技术为逃逸分析。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量 v 显然没有逃出 createStrings（）函数之外。以次为基础，虚拟机才可以大胆地将 v 内部的加锁操作去除。如果 createStringso（）返回的不是 String 数组，而是 v 本身，那么就认为变量 v 逃逸出了当前函数，也就是说 v 有可能被其他线程访问。如果是这样，虚拟机就不能消除 v 中的锁操作。</p>\n</li>\n</ol>\n<h1 id=\"threadlocal\"><a class=\"anchor\" href=\"#threadlocal\">#</a> ThreadLocal</h1>\n<p>除了控制资源的访问外，我们还可以通过增加资源来保证所有对象的线程安全。从 ThreadLocal 的名字上可以看到，这是一个线程的局部变量。也就是说，只有当前线程可以访问。既然是只有当前线程可以访问的数据，自然是线程安全的。</p>\n<h2 id=\"threadlocal的实现原理\"><a class=\"anchor\" href=\"#threadlocal的实现原理\">#</a> ThreadLocal 的实现原理</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            createMap(t, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 在 set 时，首先获得当前线程对象，然后通过 getMap () 拿到线程的 ThreadLocalMap，并将值设入 ThreadLocalMap 中。而 ThreadLocalMap 可以理解为一个 Map（虽然不是，但是你可以把它简单地理解成 HashMap），但是它是定义在 Thread 内部的成员。注意下面的定义是从 Thread 类中摘出来的：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure><br />\n 而设置到 ThreadLocal 中的数据，也正是写入了 threadLocals 这个 Map。其中，key 为 ThreadLocal 当前对象，value 就是我们需要的值。而 threadLocals 本身就保存了当前自己所在线程的所有 “局部变量”，也就是一个 ThreadLocal 变量的集。</p>\n<p>在进行 get（）操作时，自然就是将这个 Map 中的数据拿出来：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure><br />\n 首先，get () 方法也是先取得当前线程的 ThreadLocalMap 对象。然后，通过将自己作为 key 取得内部的实际数据。在了解了 ThreadLocal 的内部实现后，我们自然会引出一个问题。那就是这些变量是维护在 Thread 类内部的（ThreadLocalMap 定义所在类），这也意味着只要线程不退出，对象的引用将一直存在。</p>\n<p>此时，如果你希望及时回收对象，最好使用 ThreadLocal.remove0 方法将这个变量移除。就像我们习惯性地关闭数据库连接一样。如果你确实不需要这个对象了，那么就应该告诉虚拟机，请把它回收掉，防止内存泄露。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">             m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"无锁\"><a class=\"anchor\" href=\"#无锁\">#</a> 无锁</h1>\n<p>对于并发控制而言，锁是一种悲观的策略。它总是假设每一次的临界区操作会产生冲突，因此，必须对每次操作都小心翼翼。如果有多个线程同时需要访问临界区资源，就宁可牺牲性能让线程进行等待，所以说锁会阻塞线程执行。而无锁是一种乐观的策略，它会假设对资源的访问是没有冲突的。既然没有冲突，自然不需要等待，所以所有的线程都可以在不停顿的状态下持续执行。那遇到冲突怎么办呢？<br />\n 无锁的策略使用一种叫做比较交换的技术 <code>(CAS Compare And Swap）</code> 来鉴别线程冲突，一旦检测到冲突产生，就重试当前操作直到没有冲突为止。</p>\n<h2 id=\"cas\"><a class=\"anchor\" href=\"#cas\">#</a> CAS</h2>\n<ul>\n<li>\n<p>与锁相比，使用比较交换（下文简称 CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。</p>\n</li>\n<li>\n<p>CAS 算法的过程是这样：它包含三个参数 CAS（V，E，N），V 表示要更新的变量，E 表示预期值，N 表示新值。仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。CAS 操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p>\n</li>\n</ul>\n<h1 id=\"死锁哲学家就餐问题\"><a class=\"anchor\" href=\"#死锁哲学家就餐问题\">#</a> 死锁（哲学家就餐问题）</h1>\n<p>如果想避免死锁，除了使用无锁的函数外，另外一种有效的做法是使用第三章节介绍的重入锁，通过重入锁的中断或者限时等待可以有效规避死锁带来的问题。</p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "Java高并发程序设计"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-3/week-2/",
            "url": "https://maoyifan.github.io/computer-science/java/course-3/week-2/",
            "title": "第2章  Java并行程序基础",
            "date_published": "2020-10-25T14:47:25.000Z",
            "content_html": "<h1 id=\"有关线程你必须知道的事\"><a class=\"anchor\" href=\"#有关线程你必须知道的事\">#</a> 有关线程你必须知道的事</h1>\n<ol>\n<li>进程：进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是 <code>系统进行资源分配和调度的基本单位</code> ，是操作系统结构的基础。</li>\n<li>线程：就是轻量级进程，是 <code>程序执行的最小单位</code> 。使用多线程而不是用多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。</li>\n</ol>\n<h2 id=\"线程生命周期\"><a class=\"anchor\" href=\"#线程生命周期\">#</a> 线程生命周期</h2>\n<p><img data-src=\"/images/n2.1.jpg\" alt=\"\" /></p>\n<h1 id=\"线程的基本操作\"><a class=\"anchor\" href=\"#线程的基本操作\">#</a> 线程的基本操作</h1>\n<p>创建线程的几种方法</p>\n<ol>\n<li>继承 Thread 类<br />\n步骤：</li>\n</ol>\n<ul>\n<li>创建一个线程子类继承 Thread 类</li>\n<li>重写 run () 方法，把需要线程执行的程序放入 run 方法，线程启动后方法里的程序就会运行</li>\n<li>创建该类的实例，并调用对象的 start () 方法启动线程<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承Thread类</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread()+<span class=\"string\">&quot;:&quot;</span>+i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/*MyThread T1 = new MyThread();</span></span><br><span class=\"line\"><span class=\"comment\">        MyThread T2 = new MyThread();</span></span><br><span class=\"line\"><span class=\"comment\">        T1.start();</span></span><br><span class=\"line\"><span class=\"comment\">        T2.start();*/</span></span><br><span class=\"line\">        <span class=\"comment\">//使用匿名内部类</span></span><br><span class=\"line\">        Thread T1 = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++) &#123;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread()+<span class=\"string\">&quot;:&quot;</span>+i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        T1.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br />\n 上述代码使用匿名内部类，重载了 run（）方法，如果没有特别的需要，都可以通过继承 Thread，重载 run（）方法来自定义线程。但考虑到 Java 是单继承的，也就是说 <code>继承本身也是一种很宝贵的资源</code> ，因此，我们也可以使用 Runnable 接口来实现同样的操作。Runnable 接口是一个单方法接口，它只有一个 run（）方法：</li>\n</ul>\n<ol start=\"2\">\n<li>使用 Runnable 接口<br />\n Runnable 接口是一个单方法接口，它只有一个 run）方法：<br />\n步骤：</li>\n</ol>\n<ul>\n<li>定义一个线程类实现 Runnable 接口，并重写该接口的 run () 方法，方法中依然是包含指定执行的程序。</li>\n<li>创建一个 Runnable 实现类实例，将其作为 target 参数传入，并创建 Thread 类实例。</li>\n<li>调用 Thread 类实例的 start () 方法启动线程。<br />\n <code>Java中Runnable接口</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class=\"line\"><span class=\"comment\">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class=\"line\"><span class=\"comment\">     * thread.</span></span><br><span class=\"line\"><span class=\"comment\">     * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class=\"line\"><span class=\"comment\">     * take any action whatsoever.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@see</span>     java.lang.Thread#run()</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 默认的 Thread.run（）就是直接调用内部的 Runnable 接口。因此，使用 Runnable 接口告诉线程该做什么，更为合理。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName()+<span class=\"string\">&quot; I am Runnable&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        MyThread2 T1 = <span class=\"keyword\">new</span> MyThread2();</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(T1,<span class=\"string\">&quot;T1&quot;</span>);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ol start=\"3\">\n<li>使用 Callable 接口<br />\n Callable 接口提供了一个 call () 方法作为线程执行体，而 Runnable 接口提供的是 run () 方法，同时，call () 方法可以有返回值，而且需要用 FutureTask 类来包装 Callable 对象。<br />\n具体步骤：</li>\n</ol>\n<ul>\n<li>创建 Callable 接口的实现类，实现 call () 方法</li>\n<li>创建 Callable 实现类实例，通过 FutureTask 类来包装 Callable 对象，该对象封装了 Callable 对象的 call () 方法的返回值。</li>\n<li>将创建的 FutureTask 对象作为 target 参数传入，创建 Thread 线程实例并启动新线程。</li>\n<li>调用 FutureTask 对象的 get 方法获取返回值。</li>\n</ul>\n<p><code>Callable&lt;V&gt;</code>  接口<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> computed result</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> Exception if unable to compute a result</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n <code>使用Callable&lt;V&gt;创建线程实例</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Callable;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.FutureTask;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread3</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;I am Callable&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        MyThread3 myThread3 = <span class=\"keyword\">new</span> MyThread3();</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; task = <span class=\"keyword\">new</span> FutureTask&lt;&gt;(myThread3);</span><br><span class=\"line\">        Thread thread = <span class=\"keyword\">new</span> Thread(task);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        <span class=\"comment\">//返回值</span></span><br><span class=\"line\">        System.out.println(task.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"4\">\n<li>通过创建线程池</li>\n</ol>\n<h2 id=\"终止线程\"><a class=\"anchor\" href=\"#终止线程\">#</a> 终止线程</h2>\n<p>那如何正常的关闭一个线程呢？查阅 JDK，你不难发现 Thread 提供了一个 stop0 方法。如果你使用 stopo（）方法，就可以立即将一个线程终止，非常方便。但如果你使用的是 eclipse 之类的 IDE 写代码的话，就会立即发现 stop（）方法是一个被标注为废弃的方法。也就是说，在将来，JDK 可能就会移除该方法。<br />\n <code>为什么stop0）被废弃而不推荐使用呢？</code> <br />\nThread.stopo 方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。而这些锁恰恰是用来维持对象一致性的。如果此时，写线程写入数据正写到一半，并强行终止，那么对象就会被写坏，同时，由于锁已经被释放，另外一个等待该锁的读线程就顺理成章的读到了这个不一致的对象，悲剧也就此发生。</p>\n<p>那如果需要停止一个线程时，应该这么做呢？其实方法很简单，只是需要由我们自行决定线程何时退出就可以了。仍然用本例说明，只需要将 ChangeObjectThread 线程增加一个 stopMe（）方法即可。</p>\n<h2 id=\"线程中断\"><a class=\"anchor\" href=\"#线程中断\">#</a> 线程中断</h2>\n<p>严格地讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告知目标线程，有人希望你退出啦！至于目标线程接到通知后如何处理，则完全由目标线程自行决定。这点很重要，如果中断后，线程立即无条件退出，我们就又会遇到 stop0 方法的老问题。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> Thread.interrupt（）<span class=\"comment\">//中断线程</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> Thread.isInterrupted（）<span class=\"comment\">//判断是否被中断</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> Thread.interrupted（）<span class=\"comment\">//判断是否被中断，并清除当前中断状态</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"等待wait和通知notify\"><a class=\"anchor\" href=\"#等待wait和通知notify\">#</a> 等待（wait）和通知（notify）</h2>\n<p>为了支持多线程之间的协作，JDK 提供了两个非常重要的接口线程等待 wait () 方法和通知 notify () 方法。属于 Object 类。这也意味着任何对象都可以调用这两个方法。<br />\n这里还需要强调一点，Object.wait（）方法并不是可以随便调用的。它必须包含在对应的 synchronzied 语句中，无论是 wait（）或者 notify（）都需要首先获得目标对象的一个监视器。首先必须获得 object 对象的监视器。而 wait（）方法在执行后，会释放这个监视器。这样做的目的是使得其他等待在 object 对象上的线程不至于因为线程的休眠而全部无法正常执行。</p>\n<p><code>注意</code> ：Object.wait（）和 Thread.sleep（）方法都可以让线程等待若干时间。除了 wait（）可以被唤醒外，另外一个主要区别就是 wait）方法会释放目标对象的锁，而 Thread.sleep（）方法不会释放任何资源。</p>\n<h2 id=\"挂起suspend和继续执行resume线程\"><a class=\"anchor\" href=\"#挂起suspend和继续执行resume线程\">#</a> 挂起（suspend）和继续执行（resume）线程</h2>\n<p>不推荐使用 suspend（）去挂起线程，是因为 suspend）在导致线程暂停的同时，并不会去释放任何锁资源。此时，其他任何线程想要访问被它暂用的锁时，都会被牵连，导致无法正常继续运行。直到对应的线程上进行了 resume（）操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。但是，如果 resume（）操作意外地在 suspend（）前就执行了，那么被挂起的线程可能很难有机会被继续执行。并且，更严重的是：它所占用的锁不会被释放，因此可能会导致整个系统工作不正常。而且，对于被挂起的线程，从它的线程状态上看，居然还是 Runnable，这也会严重影响我们对系统当前状态的判断。</p>\n<h2 id=\"等待线程结束join和谦让yield\"><a class=\"anchor\" href=\"#等待线程结束join和谦让yield\">#</a> 等待线程结束（join）和谦让（yield）</h2>\n<p>多线程应用中，很多时候，一个线程的输入可能非常依赖于另外一个或者多个线程的输出，此时，这个线程就需要等待依赖线程执行完毕，才能继续执行。JDK 提供了 join（）操作来实现这个功能，如下所示，显示了 2 个 join（）方法：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException <span class=\"comment\">// 表示无限等待，它会一直阻塞当前线程，直到目标线程执行完毕</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">join</span><span class=\"params\">(<span class=\"keyword\">long</span> millis)</span> <span class=\"keyword\">throws</span> InterruptedException <span class=\"comment\">//给出了一个最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因为“等不及了”，而继续往下执行。</span></span></span><br></pre></td></tr></table></figure><br />\n<strong> 实例</strong><br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JoinMain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        AddThread addThread = <span class=\"keyword\">new</span> AddThread();</span><br><span class=\"line\">        addThread.start();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br />\n 输出为：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<p><code>使用join()后</code> <br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        AddThread addThread = <span class=\"keyword\">new</span> AddThread();</span><br><span class=\"line\">        addThread.start();</span><br><span class=\"line\">        addThread.join();</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出为：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10000</span></span><br></pre></td></tr></table></figure><br />\n 主函数中，如果不使用 join（）等待 AddThread，那么得到的 i 很可能是 0 或者一个非常小的数字。因为 AddThread 还没开始执行，i 的值就已经被输出了。但在使用 join () 方法后，表示主线程愿意等待 AddThread 执行完毕，跟着 AddThread 一起往前走，故在 join（）返回时，AddThread 已经执行完成，故 i 总是 10000。</p>\n<h2 id=\"volatile\"><a class=\"anchor\" href=\"#volatile\">#</a> volatile</h2>\n<p>volatile 不能保证原子性；能够保证可见性与有序性，禁止指令重排；<br />\n如：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PlusTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">10000</span>; k++) &#123;</span><br><span class=\"line\">              i++;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">      hread[] thread = <span class=\"keyword\">new</span> Thread[<span class=\"number\">10</span>];</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">          thread[i] = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> PlusTask());</span><br><span class=\"line\">          thread[i].start();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">          thread[i].join();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println(i);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br />\n 输出为 <code>44036</code>  结果 <code>小于100000</code> ；</p>\n<h2 id=\"线程组\"><a class=\"anchor\" href=\"#线程组\">#</a> 线程组</h2>\n<p>在一个系统中，如果线程数量很多，而且功能分配比较明确，就可以将相同功能的线程放置在一个线程组里。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadGroup tg = <span class=\"keyword\">new</span> ThreadGroup (<span class=\"string\">&quot;PrintGroup&quot;</span>); </span><br><span class=\"line\">Thread t1 = <span class=\"keyword\">new</span> Thread (tg, <span class=\"keyword\">new</span> ThreadGroupName (), <span class=\"string\">&quot;T1&quot;</span>);</span><br><span class=\"line\">Thread t2 = <span class=\"keyword\">new</span> Thread (tg, <span class=\"keyword\">new</span> ThreadGroupName (), <span class=\"string\">&quot;T2&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"守护线程daemon\"><a class=\"anchor\" href=\"#守护线程daemon\">#</a> 守护线程（Daemon）</h2>\n<p>守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程、就可以理解为守护线程。与之相对应的是用户线程，用户线程可以认为是系统的工作线程，它会完成这个程序应该要完成的业务操作。如果用户线程全部结束，这也意味着这个程序实际上无事可做了。守护线程要守护的对象已经不存在了，那么整个应用程序就自然应该结束。因此，当一个 Java 应用内，只有守护线程时，Java 虚拟机就会自然退出。</p>\n<h2 id=\"线程优先级\"><a class=\"anchor\" href=\"#线程优先级\">#</a> 线程优先级</h2>\n<p>在 Java 中，使用 1 到 10 表示线程优先级。一般可以使用内置的三个静态标量表示：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MIN PRIORITY = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> NORM PRIORITY =<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX PRIORITY =<span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"synchronized\"><a class=\"anchor\" href=\"#synchronized\">#</a> synchronized</h2>\n<p>synchronized 能够保证原子性、可见性、有序性；<br />\n关键字 synchronized 可以有多种用法。</p>\n<ul>\n<li>指定加锁对象：对给定对象加锁，进入同步代码前要获得给定对象的锁。</li>\n<li>直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。</li>\n<li>直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "Java",
                "Java高并发程序设计"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-7/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-7/",
            "title": "第七章 常见面试题总结",
            "date_published": "2020-10-24T11:23:25.000Z",
            "content_html": "<p><code>来源网络收集</code></p>\n<h1 id=\"jvm启动模式\"><a class=\"anchor\" href=\"#jvm启动模式\">#</a> JVM 启动模式</h1>\n<ol>\n<li>指定 JVM 启动模式<br />\n可以通过 <code>-server</code>  或者 <code>-client</code>  参数指定启动模式。</li>\n<li>两种模式的区别</li>\n</ol>\n<ul>\n<li>编译器方面<br />\n当虚拟机运行在 client 模式时，使用的是一个代号为 c1 的轻量级编译器，而 server 模式启动，虚拟机采用相对重量级，代号为 c2 的编译器；c2 编译器比 c1 编译器性能更高。</li>\n<li>GC 方面<br />\n client 模式下的新生代采用 (Serial 收集器)、老年代 (Serial Old) 收集器，选择的是串行 GC。<br />\nserver 模式下的新生代和老年代均选择并行 GC；</li>\n<li>启动方面<br />\n client 模式启动快、编译快、内存占用少、针对桌面级应用、优化客户端环境的启用时间。<br />\nserver 模式启动慢、编译更完全、效率高、针对服务端应用、优化服务器环境的最大执行速度。</li>\n</ul>\n<h1 id=\"如何优化java-gc\"><a class=\"anchor\" href=\"#如何优化java-gc\">#</a> 如何优化 Java GC</h1>\n<ol>\n<li>先描述 GC 及 GC 算法。</li>\n<li>优化方向</li>\n</ol>\n<ul>\n<li>降低进入老年代的对象数量</li>\n<li>较少 FULL GC 的次数</li>\n<li>优化 JVM 参数：堆和栈的大小、设置垃圾回收器的模式。</li>\n</ul>\n<h1 id=\"java8的元空间\"><a class=\"anchor\" href=\"#java8的元空间\">#</a> Java8 的元空间</h1>\n<p>方法区：所有线程共享，存储类的信息、常量池、方法数据、方法代码。元空间与方法区的最大区别：元空间存放在本地内存而不是虚拟机中。<br />\n<strong>为什么用元空间代替方法区</strong></p>\n<ul>\n<li>字符串在永久代中，容易出现性能问题及内存溢出；</li>\n<li>类及方法的信息比较难确定大小，对于永久代的指定比较困难、太小永久代容易溢出、太大容易导致老年代溢出；</li>\n<li>永久代会为 GC 带来不必要的复杂度，回收效率偏低。</li>\n</ul>\n<h1 id=\"jvm进程会启动哪些线程\"><a class=\"anchor\" href=\"#jvm进程会启动哪些线程\">#</a> JVM 进程会启动哪些线程？</h1>\n<p>每当使用 java 命令执行一个带 main 方法的类时，就会启动 JVM（应用程序），实际上就是在操作系统中启动一个 JVM 进程，JVM 启动时，必然会创建以下 5 个线程：</p>\n<ul>\n<li>1-main                          主线程，执行我们指定的启动类的 main 方法</li>\n<li>2-Reference Handler             处理引用的线程</li>\n<li>3-Finalizer                     调用对象的 finalize 方法的线程，就是垃圾回收的线程</li>\n<li>4-Signal Dispatcher             分发处理发送给 JVM 信号的线程</li>\n<li>5-Attach Listener               负责接收外部的命令的线程</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-6/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-6/",
            "title": "第六章 虚拟机字节码执行引擎",
            "date_published": "2020-10-24T10:38:25.000Z",
            "content_html": "<p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确是编程语言发展的一大步！</code></p>\n<h1 id=\"运行时栈帧结构\"><a class=\"anchor\" href=\"#运行时栈帧结构\">#</a> 运行时栈帧结构</h1>\n<p>栈帧（ Stack Frame） 是用于支持虚拟机进行方法调用和方法执行的数据结构， 它是虚拟机运行时数据区中的虚拟机栈（ Virtual Machine Stack） [1] 的栈元素。 栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。<br />\n<img data-src=\"/images/6.1.jpg\" alt=\"\" /></p>\n<h2 id=\"局部变量表\"><a class=\"anchor\" href=\"#局部变量表\">#</a> 局部变量表</h2>\n<p>局部变量表（ Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p>\n<h2 id=\"操作数栈\"><a class=\"anchor\" href=\"#操作数栈\">#</a> 操作数栈</h2>\n<p>操作数栈（ Operand Stack）也常称为操作栈，它是一个后入先出（LastInFirstOut,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到 Code 属性的 max_stacks 数据项中。<br />\n操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点， 在类校验阶段的数据流分析中还要再次验证这一点。</p>\n<h2 id=\"动态连接\"><a class=\"anchor\" href=\"#动态连接\">#</a> 动态连接</h2>\n<p>每个栈帧都包含一个指向运行时常量池 [1] 中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（ Dynamic Linking）。</p>\n<h2 id=\"方法返回地址\"><a class=\"anchor\" href=\"#方法返回地址\">#</a> 方法返回地址</h2>\n<p>当一个方法开始执行后， 只有两种方式可以退出这个方法： <code>正常调用完成</code> 、 <code>异常调用完成</code> 。<br />\n无论采用何种退出方式， 在方法退出之后， 都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的， 栈帧中一般不会保存这部分信息。</p>\n<h2 id=\"附加信息\"><a class=\"anchor\" href=\"#附加信息\">#</a> 附加信息</h2>\n<p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-5/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-5/",
            "title": "第五章 虚拟机类加载机制",
            "date_published": "2020-10-22T12:37:25.000Z",
            "content_html": "<p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确是编程语言发展的一大步！</code></p>\n<h1 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h1>\n<p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>\n<h1 id=\"类加载时机\"><a class=\"anchor\" href=\"#类加载时机\">#</a> 类加载时机</h1>\n<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括： 加载（ Loading）、验证（Verification）、准备（ Preparation）、解析（ Resolution）、初始化（ Initialization）、使用（Using）和卸载（Unloading）7 个阶段。 其中验证、 准备、 解析 3 个部分统称为连接（ Linking）。<br />\n <code>类的生命周期</code> <br />\n<img data-src=\"/images/5.1.jpg\" alt=\"\" /></p>\n<p>什么情况下需要开始类加载过程的第一个阶段： 加载？ Java 虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。 但是对于初始化阶段， 虚拟机规范则是严格规定了有且只有 6 种情况必须立即对类进行 “初始化” （而加载、 验证、 准备自然需要在此之前开始）。</p>\n<ul>\n<li>遇到 new、 getstatic、 putstatic 或 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化；</li>\n<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化；</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（ 包含 main（）方法的那个类） ，虚拟机会先初始化这个主类；</li>\n<li>当使用 JDK 1.7 的动态语言支持时， 如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、 REF_putStatic<br />\n、REF_ivokeStatic、REF_newIvokeStatic 的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化；</li>\n<li>当一个接口中定义了 JDK8 新加入的默认方法时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n</ul>\n<h1 id=\"类加载的过程\"><a class=\"anchor\" href=\"#类加载的过程\">#</a> 类加载的过程</h1>\n<ol>\n<li>加载<br />\n <code>加载</code> 是 “类加载” （ Class Loading） 过程的一个阶段， 希望读者没有混淆这两个看起来很相似的名词。在加载阶段， 虚拟机需要完成以下 3 件事情：</li>\n</ol>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>\n<li>在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的访问入口.<br />\n <code>注意</code> ： 没有指明二进制字节流要从一个 Class 文件中获取，准确地说是根本没有指明要从哪里获取、 怎样获取。因此可以从 ZIP 包中读取、从网络中获取， 这种场景最典型的应用就是 Applet、运行时计算生成，这种场景使用得最多的就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 “*$Proxy” 的代理类的二进制字节流</li>\n</ul>\n<ol start=\"2\">\n<li>验证<br />\n验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br />\n验证阶段大致会完成四个阶段的验证动作：</li>\n</ol>\n<ul>\n<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范， 并且能被当前版本的虚拟机处理。</li>\n<li>元数据验证：对字节码描述的信息进行语义分析， 以保证其描述的信息符合 Java 语言规范的要求</li>\n<li>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对 <code>类的方法体</code> 进行校验分析， 保证被校验类的方法在运行时不会做出危害虚拟机安全的事件</li>\n<li>符合引用验证：符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个 java.lang.IncompatibleClassChangeError 异常的子类.</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>准备<br />\n准备阶段是正式为类变量分配内存并设置类变量初始值的阶段， 这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下， 首先， 这时候进行内存分配的仅包括类变量（ 被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 其次， 这里所说的初始值 “通常情况” 下是数据类型的 <code>零值</code> .<br />\n 如果类字段的字段属性表中存在 ConstantValue 属性， 那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值如：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value = <span class=\"number\">123</span>；</span><br></pre></td></tr></table></figure><br />\n<strong> 基本类型的零值：</strong><br />\n<img data-src=\"/images/5.2.jpg\" alt=\"\" /></p>\n</li>\n<li>\n<p>解析<br />\n解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。<br />\n主要包括： <code>类或接口的解析</code> 、 <code>字段解析</code> 、 <code>方法解析</code> .</p>\n</li>\n<li>\n<p>初始化<br />\n开始真正执行 Java 代码，执行 clinit () 方法，该方法会收集所有类型变量的赋值动作、静态语句的合并产生、首先会执行父类。</p>\n</li>\n</ol>\n<h1 id=\"类加载器\"><a class=\"anchor\" href=\"#类加载器\">#</a> 类加载器</h1>\n<p>虚拟机设计团队把类加载阶段中的 “通过一个类的全限定名来获取描述此类的二进制字节流” 这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为 <code>类加载器</code> 。</p>\n<h2 id=\"类与类加载器\"><a class=\"anchor\" href=\"#类与类加载器\">#</a> 类与类加载器</h2>\n<p>类加载器虽然只用于实现类的加载动作， 但它在 Java 程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否 “相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义， 否则， 即使这两个类来源于同一个 Class 文件， 被同一个虚拟机加载， 只要加载它们的类加载器不同， 那这两个类就必定不相等。</p>\n<h2 id=\"双亲委派模型\"><a class=\"anchor\" href=\"#双亲委派模型\">#</a> 双亲委派模型</h2>\n<p>从 Java 虚拟机的角度来讲， 只存在两种不同的类加载器：一种是启动类加载器（ Bootstrap Classloader) 加<br />\n载器使用 C++ 语言实现 [1]，是虚拟机自身的一部分； 另一种就是所有其他的类加载器， 这些类加载器都由 Java 语言实现，独立于虚拟机外部， 并且全都继承自抽象类 java.lang.ClassLoader。<br />\n三层类加载器：</p>\n<ul>\n<li>启动类加载器：这个类将器负责将存放在＜JAVA_HOME＞\\lib 目录中的， 或者被 - Xbootclasspath 参数所指定的路径中的， 并且是虚拟机识别的（ 仅按照文件名识别， 如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载） 类库加载到虚拟机内存中。</li>\n<li>加载器由 sun.misc.Launcher $ExtClassLoader 实现， 它负责<br />\n加载＜JAVA_HOME＞\\lib\\ext 目录中的， 或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>\n<li>这个类加载器由 sun.misc.Launcher $App-ClassLoader 实现。 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader（ ） 方法的返回值， 所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>\n</ul>\n<p><code>双亲委派模型</code> :<br />\n<img data-src=\"/images/5.3.jpg\" alt=\"\" /><br />\n 双亲委派模型要求除了顶层的启动类加载器外， 其余的类加载器都应当有自己的父类加载器。<br />\n双亲委派模型的工作过程是： 如果一个类加载器收到了类加载的请求， 它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成， 每一个层次的类加载器都是如此， 因此所有的加载请求最终都应该传送到顶层的启动类加载器中， 只有当父加载器反馈自己无法完成这个加载请求（ 它的搜索范围中没有找到所需的类）时， 子加载器才会尝试自己去加载。<br />\n <code>优点</code> :<br />\n 好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个<br />\n类，最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此 Object 类在程序的各种类加载器环境中都是同一个类。 相反，如果没有使用双亲委派模型， 由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中， 那系统中将会出现多个不同的 Object 类， Java 类型体系中最基础的行为也就无法保证， 应用程序也将会变得一片混乱。</p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-4/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-4/",
            "title": "第四章 类文件结构",
            "date_published": "2020-10-22T11:40:25.000Z",
            "content_html": "<p><code>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，确是编程语言发展的一大步！</code></p>\n<h1 id=\"类文件结构\"><a class=\"anchor\" href=\"#类文件结构\">#</a> 类文件结构</h1>\n<h2 id=\"无关系的基石\"><a class=\"anchor\" href=\"#无关系的基石\">#</a> 无关系的基石</h2>\n<p>各种不同平台的 Java 虚拟机，以及所有平台都统一支持的程序存储格式 <code>字节码</code> 是构成平台无关性的基石。<br />\n实现语言无关性的基础仍然是虚拟机和字节码存储格式。 Java 虚拟机不和包括 Java 在内的任何语言绑定，它只与 <code>Class文件</code> 这种特定的二进制文件格式所关联， Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。<br />\n<img data-src=\"/images/4.1.jpg\" alt=\"\" /></p>\n<h2 id=\"class-类文件的结构\"><a class=\"anchor\" href=\"#class-类文件的结构\">#</a> Class 类文件的结构</h2>\n<p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据， 没有空隙存在。<br />\nClass 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据， 这种伪结构中只有两种数据类型： <code>无符号数</code> 和 <code>表</code> .<br />\n<img data-src=\"/images/4.2.jpg\" alt=\"\" /></p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-3/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-3/",
            "title": "第三章 垃圾收集器与内存分配",
            "date_published": "2020-10-21T11:00:25.000Z",
            "content_html": "<p>:::note info<br />\n 以下为个人学习笔记和习题整理<br />\n:::</p>\n<h1 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h1>\n<h2 id=\"垃圾收集需要完成的三件事\"><a class=\"anchor\" href=\"#垃圾收集需要完成的三件事\">#</a> 垃圾收集需要完成的三件事</h2>\n<ul>\n<li>哪些内存需要回收？</li>\n<li>什么时候回收？</li>\n<li>如何回收？<br />\nJava 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。<br />\n <code>Java堆和方法区</code> 则不一样， 一个接口中的多个实现类需要的内存可能不一样， 一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。</li>\n</ul>\n<h1 id=\"如何判断对象已死\"><a class=\"anchor\" href=\"#如何判断对象已死\">#</a> 如何判断对象已死？</h1>\n<h2 id=\"引用计数法\"><a class=\"anchor\" href=\"#引用计数法\">#</a> 引用计数法</h2>\n<p>对象中添加一个引用计数器， 每当有一个地方引用它时，计数器值就加 <code>1</code> ；当引用失效时，计数器值就减 <code>1</code> ；任何时刻计数器为 <code>0</code>  的对象就是不可能再被使用的。<br />\n <code>缺点：</code> <br />\n主流的 Java 虚拟机里面没有选用引用计数算法来管理内存， 其中最主要的原因是它 <code>很难解决对象之间相互循环引用</code> 的问题。</p>\n<h2 id=\"可达性分析\"><a class=\"anchor\" href=\"#可达性分析\">#</a> 可达性分析</h2>\n<p>这个算法的基本思路就是通过一系列的称为 <code>GC Roots</code>  的对象作为起始点，从这些节点开始向下搜索， 搜索所走过的路径称为引用链（ Reference Chain） ， 当一个对象到 GC Roots 没有任何引用链相连（ 用图论的话来说， 就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。<br />\n<img data-src=\"/images/3.1.jpg\" alt=\"\" /><br />\n在 Java 语言中， 可作为 GC Roots 的对象包括下面几种:</p>\n<ul>\n<li>虚拟机栈（ 栈帧中的本地变量表） 中引用的对象；</li>\n<li>方法区中类静态属性引用的对象；</li>\n<li>方法区中常量引用的对象；</li>\n<li>本地方法栈中 JNI（ 即一般说的 Native 方法）引用的对象；</li>\n<li>所有被同步锁（synchronized 关键字）持有的对象等等。</li>\n</ul>\n<h2 id=\"引用\"><a class=\"anchor\" href=\"#引用\">#</a> 引用</h2>\n<p>无论是通过引用计数算法判断对象的引用数量， 还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与 <code>引用</code> 有关。<br />\n在 JDK 1.2 之后， Java 对引用的概念进行了扩充， 将引用分为 <code>强引用（ Strong Reference）</code> 、 <code>软引用（ Soft Reference）</code> 、 <code>弱引用（Weak Reference）</code> 、<br />\n <code>虚引用（ Phantom Reference）</code>  4 种， 这 4 种引用强度依次逐渐减弱。</p>\n<ul>\n<li>强引用：指在程序代码之中普遍存在的，类似 <code>“Object obj=new Object（ ）”</code>  这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象.</li>\n<li>软引用：对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存， 才会抛出内存溢出异常。 在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。</li>\n<li>弱引用：它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 在 JDK1.2 之后， 提供了 WeakReference 类来实现弱引用。</li>\n<li>虚引用：一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这<br />\n个对象被收集器回收时收到一个系统通知。 在 JDK 1.2 之后， 提供了 PhantomReference 类来实现虚引用。</li>\n</ul>\n<h2 id=\"对象是生存还是死亡\"><a class=\"anchor\" href=\"#对象是生存还是死亡\">#</a> 对象是生存还是死亡？</h2>\n<p>即使在可达性分析算法中不可达的对象，也并非是 “非死不可” 的，这时候它们暂时处于 “ 缓刑” 阶段，要真正宣告一个对象死亡，至少要经历 <code>两次标记过程</code> ： 如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize () 方法。 当对象没有覆盖 finalize () 方法， 或者 finalize () 方法已经被虚拟机调用过， 虚拟机将这两种情况都视为 “ 没有必要执行” 。<br />\n如果这个对象被判定为有必要执行 finalize () 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。<br />\nfinalize（）方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize () 中成功拯救自己 —— 只要重新与引用链上的任何一个对象建立关联即可， 譬如把自己（this 关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出 “即将回收” 的集合； 如果对象这时候还没有逃脱， 那基本上它就真的被回收了。<br />\n任何一个对象的 finalize () 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize () 方法不会被再次执行，自救失败。</p>\n<h2 id=\"回收方法区\"><a class=\"anchor\" href=\"#回收方法区\">#</a> 回收方法区</h2>\n<p>方法区的垃圾收集主要回收两部分内容： 废弃常量和不再使用的类型。</p>\n<h1 id=\"垃圾回收算法\"><a class=\"anchor\" href=\"#垃圾回收算法\">#</a> 垃圾回收算法</h1>\n<h2 id=\"1标记-清除算法老年代\"><a class=\"anchor\" href=\"#1标记-清除算法老年代\">#</a> 1. 标记 - 清除算法 (老年代)</h2>\n<p>算法分为 “标记” 和 “清除” 两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。<br />\n<img data-src=\"/images/3.2.jpg\" alt=\"\" /></p>\n<p><code>缺点</code> ：</p>\n<ul>\n<li>一个是效率问题， 标记和清除两个过程的效率都不高；</li>\n<li>一个是空间问题， 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>\n</ul>\n<h2 id=\"2标记-复制算法新生代常用\"><a class=\"anchor\" href=\"#2标记-复制算法新生代常用\">#</a> 2. 标记 - 复制算法 (新生代常用)</h2>\n<p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。<br />\n<img data-src=\"/images/3.3.jpg\" alt=\"\" /></p>\n<p><code>优点</code> :<br />\n 每次都是对整个半区进行内存回收， 内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br />\n <code>缺点</code> :<br />\n 这种算法的代价是将内存缩小为了原来的一半， 未免太高了一点。</p>\n<h2 id=\"3标记-整理算法老年代\"><a class=\"anchor\" href=\"#3标记-整理算法老年代\">#</a> 3. 标记 - 整理算法 (老年代)</h2>\n<p>根据老年代的特点，有人提出了另外一种 “标记 - 整理”，标记过程仍然与 “标记 - 清除” 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动， 然后直接清理掉端边界以外的内存。<br />\n<img data-src=\"/images/3.4.jpg\" alt=\"\" /></p>\n<p>“标记 - 整理” 与 “标记 - 清除” 最本质的区别在于是否移动；是否移动都存在弊端。不移动时间会更短，但是吞吐量小。<br />\n <code>因此：HotSpot虚拟机中，关注吞吐量的Parallel Old收集器是标记-整理算法；而关注延迟的CMS收集器则用的标记-清除算法。</code></p>\n<h1 id=\"经典的垃圾收集器\"><a class=\"anchor\" href=\"#经典的垃圾收集器\">#</a> 经典的垃圾收集器</h1>\n<p><img data-src=\"/images/3.5.jpg\" alt=\"\" /></p>\n<h2 id=\"serial-收集器\"><a class=\"anchor\" href=\"#serial-收集器\">#</a> Serial 收集器</h2>\n<p>这个收集器是一个单线程的收集器，但它的 “单线程” 的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时， 必须暂停其他所有的工作线程，直到它收集结束。<br />\n下图示意了 Serial/Serial Old 收集器的运行过程<br />\n<img data-src=\"/images/3.6.jpg\" alt=\"\" /></p>\n<p>Serial 收集器对于运行在 Client 模式下的虚拟机来说是一个很好的选择</p>\n<h2 id=\"parnew-收集器\"><a class=\"anchor\" href=\"#parnew-收集器\">#</a> ParNew 收集器</h2>\n<p>ParNew 收集器其实就是 Serial 收集器的多线程版本。它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器， 其中有一个与性能无关但很重要的原因是， 除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。<br />\n<img data-src=\"/images/3.7.jpg\" alt=\"\" /></p>\n<p>CMS 收集器是 HotSpot 虚拟机中第一款真正意义上的并发（ Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（ 基本上） 同时工作。</p>\n<h2 id=\"parallel-scavebge收集器\"><a class=\"anchor\" href=\"#parallel-scavebge收集器\">#</a> Parallel Scavebge 收集器</h2>\n<p>ParallelScavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器.ParallelScavenge 收集器的特点是它的关注点与其他收集器不同， CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间， 而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（ Throughput） 。吞吐量 = 运行用户代码时间 /（ 运行用户代码时间 + 垃圾收集时间） .</p>\n<h2 id=\"serial-old收集器\"><a class=\"anchor\" href=\"#serial-old收集器\">#</a> Serial Old 收集器</h2>\n<p>Serial Old 是 Serial 收集器的老年代版本， 它同样是一个单线程收集器， 使用 “标记 - 整理” 算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。<br />\n<img data-src=\"/images/3.8.jpg\" alt=\"\" /></p>\n<h2 id=\"paraller-old收集器\"><a class=\"anchor\" href=\"#paraller-old收集器\">#</a> Paraller Old 收集器</h2>\n<p>Parallel Old 是 Parallel Scavenge 收集器的老年代版本， 使用多线程和 “标记 - 整理” 算法。 这个收集器是在 JDK 1.6 中才开始提供的， 在此之前， 新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态。 原因是， 如果新生代选择了 Parallel Scavenge 收集器， 老年代除了 Serial Old（ PS MarkSweep） 收集器外别无选择（ 还记得上面说过 Parallel Scavenge 收集器无法与 CMS 收集器配合工作吗（原因：CMS 追求低延迟，Parallel Scavenge 面向高吞吐量，以及使用的分代框架不一））。<br />\n<img data-src=\"/images/3.9.jpg\" alt=\"\" /></p>\n<p><code>Parallel Old收集器出现后， “ 吞吐量优先” 收集器终于有了比较名副其实的应用组合， 在注重吞吐量以及CPU资源敏感的场合， 都可以优先考虑Parallel Scavenge加Parallel Old收集器 </code> .</p>\n<h2 id=\"cms-收集器\"><a class=\"anchor\" href=\"#cms-收集器\">#</a> CMS 收集器</h2>\n<p>CMS（ Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，CMS 收集器是基于 “标记 — 清除” 算法实现，整个过程分为 4 个步骤：</p>\n<ul>\n<li>初始标记（ CMS initial mark）：初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象， 速度很快。(需要 Stop the word).</li>\n<li>并发标记（ CMS concurrent mark）: 并发标记阶段就是进行 GC RootsTracing 的过程，耗时长，但不需要暂停用户进程；</li>\n<li>重新标记（ CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录， 这个阶段的停顿时间一般会比初<br />\n始标记阶段稍长一些， 但远比并发标记的时间短 (需要 Stop the word).</li>\n<li>并发清除（ CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以与用户进程同时并发的。<br />\n<img data-src=\"/images/3.10.jpg\" alt=\"\" /></li>\n</ul>\n<p><code>缺点</code> ：</p>\n<ul>\n<li>CMS 收集器对 CPU 资源非常敏感。在并发阶段， 它虽然不会导致用户线程停顿， 但是会因为占用了一部分线程（ 或者说 CPU 资源） 而导致应用程序变慢， 总吞吐量会降低；</li>\n<li>CMS 收集器无法处理浮动垃圾（ Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。</li>\n<li>收集结束时会有大量空间碎片产生；原因： CMS 收集器是基于 “标记 — 清除” 算法实现。</li>\n</ul>\n<h2 id=\"garbage-first-收集器\"><a class=\"anchor\" href=\"#garbage-first-收集器\">#</a> Garbage First 收集器</h2>\n<p>G1 是一款面向服务端应用的垃圾收集器。与其他 GC 收集器相比，唯一一个同时可用于年轻代和老年代的收集器。<br />\nG1 收集器的运作大致可划分为以下几个步骤：<br />\n初始标记（ Initial Marking）<br />\n并发标记（ Concurrent Marking）<br />\n最终标记（ Final Marking）<br />\n筛选回收（ Live Data Counting and Evacuation）<br />\nG1 具备如下特点。</p>\n<ul>\n<li>并行与并发</li>\n<li>按收益动态回收垃圾</li>\n<li>可以指定最大停顿时间</li>\n<li>分 Region 的内存布局</li>\n<li>空间整合：与 CMS 的 “标记 — 清理” 算法不同， G1 从整体来看是基于 “ 标记 — 整理” 算法实现的收集器，从局部（ 两个 Region 之间） 上来看是基于 “ 复制” 算法实现的， 但无论如何， 这两种算法都意味着 G1 运作期间不会产生内存空间碎片， 收集后能提供规整的可用内存。</li>\n<li>可以预测停顿时间</li>\n</ul>\n<h2 id=\"吞吐量和低延迟如何选择收集器\"><a class=\"anchor\" href=\"#吞吐量和低延迟如何选择收集器\">#</a> 吞吐量和低延迟如何选择收集器</h2>\n<ol>\n<li>吞吐量优先：新生代采用 Parallel Scavebge，老年代采用 Paraller Old，并配置多个线程进行回收。设置参数来调整最大停顿时间和吞吐量的大小；</li>\n<li>低延迟优先：老年代采用 CMS，年轻代采用 ParNew 收集器（多线程）。</li>\n</ol>\n<h1 id=\"实战内存分配与回收\"><a class=\"anchor\" href=\"#实战内存分配与回收\">#</a> 实战：内存分配与回收</h1>\n<h2 id=\"对象优先在eden-分配\"><a class=\"anchor\" href=\"#对象优先在eden-分配\">#</a> 对象优先在 Eden 分配</h2>\n<p>大多数情况下，对象在新生代 Eden 分配。当 Eden 中没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>\n<ol>\n<li>Minor GC 和 Full GC 不同之处</li>\n</ol>\n<ul>\n<li>Minor GC：发生在新生代的垃圾回收，非常频繁，速度也很快。</li>\n<li>Major GC：发生在老年代。</li>\n<li>Full GC: 清理整个堆空间。</li>\n</ul>\n<h2 id=\"什么时候对象进入老年代\"><a class=\"anchor\" href=\"#什么时候对象进入老年代\">#</a> 什么时候对象进入老年代</h2>\n<ol>\n<li>大对象直接进入老年代：大对象是指， 需要大量连续内存空间的 Java 对象， 最典型的大对象就是那种很长的字符串以及数组；<br />\n虚拟机提供了一个 - XX：  <code>PretenureSizeThreshold参数</code> 令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制</li>\n<li>长期存活的对象将进入老年代：虚拟机给每个对象定义了一个对象年龄（ Age） 计数器。 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活， 并且能被 Survivor 容纳的话， 将被移动到 Survivor 空间中， 并且对象年龄设为 1。 对象在 Survivor 区中每 “熬过” 一次 Minor GC， 年龄就增加 1 岁， 当它的年龄增加到一定程度（ 默认为 15 岁） ，就将会被晋升到老年代中。<br />\n对象晋升老年代的年龄阈值， 可以通过参数 - XX：  <code>MaxTenuringThreshold设置</code> .</li>\n<li>动态对象年龄判定：为了能更好地适应不同程序的内存状况， 虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。</li>\n<li>空间分配担保：发生 Minor GC 之前， 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间， 如果这个条件成立，<br />\n那么 Minor GC 可以确保是安全的。 如果不成立， 则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，<br />\n如果大于， 将尝试着进行一次 Minor GC， 尽管这次 Minor GC 是有风险的；<br />\n如果小于， 或者 HandlePromotionFailure 设置不允许冒险， 那这时也要改为进行一次 Full GC。</li>\n</ol>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-2/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-2/",
            "title": "第二章 Java内存区域与内存溢出异常",
            "date_published": "2020-10-20T13:28:25.000Z",
            "content_html": "<p><code>Java与C++之间有一堵由内存动态分配和垃圾收集技术围城的高墙，墙外的人想进去，墙里面的人却想出来！</code></p>\n<h1 id=\"运行时数据区\"><a class=\"anchor\" href=\"#运行时数据区\">#</a> 运行时数据区</h1>\n<p><img data-src=\"/images/timg.jpg\" alt=\"\" /></p>\n<h2 id=\"程序计数器\"><a class=\"anchor\" href=\"#程序计数器\">#</a> 程序计数器</h2>\n<p><code>线程私有</code> ，它是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<br />\n由于 Java 虚拟机的多线程是通过线程轮流切换、分配器处理执行时间的方式实现的。任一时刻，一个处理器都只会处理一条线程中的指令。因此，为了<br />\n线程切换后能够恢复到正确的执行位置，每个线程都需要一个独立的程序计数器。<br />\n此内存区域是唯一一个在《Java 虚拟机规范》中没有规定任何 OutOfMemoryError 的区域。</p>\n<h2 id=\"java虚拟机栈\"><a class=\"anchor\" href=\"#java虚拟机栈\">#</a> Java 虚拟机栈</h2>\n<p><code>线程私有</code> ，与线程的生命周期相同。每个方法被执行时，Java 虚拟机栈都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等。局部变量表中存放编译期可知的基本数据类型（boolean、byte、char、shor、int、long、float、double）、对象引用和 returnAddress（指向一条字节码指令的地址）。<br />\n两类异常：</p>\n<ul>\n<li>线程请求的栈深度大于虚拟机所允许的深度、将抛出 StackOverflowError 异常；</li>\n<li>如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存将会抛出 OutOfMemoryError 异常。</li>\n</ul>\n<h2 id=\"本地方法栈\"><a class=\"anchor\" href=\"#本地方法栈\">#</a> 本地方法栈</h2>\n<p><code>线程私有</code> ，为虚拟机使用本地方法提供服务。<br />\n两类异常：</p>\n<ul>\n<li>线程请求的栈深度大于虚拟机所允许的深度、将抛出 StackOverflowError 异常；</li>\n<li>如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存将会抛出 OutOfMemoryError 异常。</li>\n</ul>\n<h2 id=\"java堆\"><a class=\"anchor\" href=\"#java堆\">#</a> Java 堆</h2>\n<p><code>线程共享</code> ，此内存区域的唯一目的：存放对象实例。“所有的对象实例及数组都应当在堆上分配”。<br />\nJava 堆是垃圾收集器管理的内存区域，又叫 “GC 堆”。Java 堆中没有完成实例分配将会抛出 OutOfMemoryError 异常。</p>\n<h2 id=\"方法区\"><a class=\"anchor\" href=\"#方法区\">#</a> 方法区</h2>\n<p><code>线程共享</code> ，用于存储已被虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据。<br />\n <code>JDK8</code>  以后完全放弃方法区的概念，改为在本地内存中实现的元空间。<br />\n如果方法区无法满足新的内存分配的需求时，将会抛出 OutOfMemoryError 异常。</p>\n<h1 id=\"hotspot虚拟机对象探秘\"><a class=\"anchor\" href=\"#hotspot虚拟机对象探秘\">#</a> HotSpot 虚拟机对象探秘</h1>\n<h2 id=\"对象的创建\"><a class=\"anchor\" href=\"#对象的创建\">#</a> 对象的创建</h2>\n<p>在类加载检查通过后， 接下来虚拟机将为新生对象分配内存。<br />\n <code>指针碰撞</code> <br />\n假设 Java 堆中内存是绝对规整的， 所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离， 这种分配方式称为 “指针碰撞” （ Bump the Pointer）。<br />\n <code>空闲列表</code> <br />\n如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，就没有办法简单地进行指针碰撞了。虚拟机就必须维护一个列表，记录上哪些内存块是可用的在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录。</p>\n<h2 id=\"对象的内存布局\"><a class=\"anchor\" href=\"#对象的内存布局\">#</a> 对象的内存布局</h2>\n<p>对象在内存中存储的布局可以分为 3 块区域： 对象头（Header）、实例数据（InstanceData）、对齐填充（ Padding）。<br />\n <code>对象头</code></p>\n<ul>\n<li>对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（ HashCode）、GC 分代年龄、 锁状态标志、 线程持有的锁、 偏向线程 ID、 偏 向时间戳等， 这部分数据的长度在 32 位和 64 位的虚拟机（ 未开启压缩指针）中分别为 32bit 和 64bit，官方称它为 “Mark Word” 。</li>\n<li>另外一部分是类型指针， 即对象指向它的类元数据的指针， 虚拟机通过这个指针来确定这个对象是哪个类的实例。<br />\n <code>实例数据</code> <br />\n实例数据部分是对象真正存储的有效信息， 也是在程序代码中所定义的各种类型的字段内容。 无论是从父类继承下来的， 还是在子类中定义的，需要记录起来。<br />\n <code>对齐填充</code> <br />\n仅仅起着占位符的作用。 由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍， 换句话说， 就是对象的大小必须是 8 字节的整数倍。 而对象头部分正好是 8 字节的倍数（ 1 倍或者 2 倍），因此，当对象实例数据部分没有对齐时， 就需要通过对齐填充来补全。</li>\n</ul>\n<h2 id=\"对象的访问定位\"><a class=\"anchor\" href=\"#对象的访问定位\">#</a> 对象的访问定位</h2>\n<p>主流的访问方式主要有两种：</p>\n<ul>\n<li>句柄<br />\n如果使用句柄访问的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，</li>\n<li>直接指针<br />\n使用直接指针访问， 那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。<br />\n <code>优缺点</code> <br />\n句柄来访问的最大好处就是 reference 中存储的是稳定的句柄地址， 在对象被移动时只会改变句柄中的实例数据指针， 而 reference 本身不需要修改。<br />\n直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。（HotSpot 使用这种）。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-2/week-1/",
            "url": "https://maoyifan.github.io/computer-science/java/course-2/week-1/",
            "title": "第一章 走进Java",
            "date_published": "2020-10-20T12:28:25.000Z",
            "content_html": "<p>:::note info<br />\n 以下为个人学习笔记和习题整理<br />\n:::</p>\n<h1 id=\"java技术体系\"><a class=\"anchor\" href=\"#java技术体系\">#</a> Java 技术体系</h1>\n<p><img data-src=\"/images/timg2.jpg\" alt=\"\" /></p>\n<h3 id=\"jdk\"><a class=\"anchor\" href=\"#jdk\">#</a> JDK</h3>\n<p>Java 程序设计语言、Java 虚拟机、Java 类库。JDK 是支持 <code>Java程序开发</code> 的最小环境。</p>\n<h3 id=\"jre\"><a class=\"anchor\" href=\"#jre\">#</a> JRE</h3>\n<p>Java 类库中的 API 中的 JavaSE API 子集和 Java 虚拟机。是 <code>Java程序运行</code> 的标准环境。</p>\n<h3 id=\"java技术体系主要产品线\"><a class=\"anchor\" href=\"#java技术体系主要产品线\">#</a> Java 技术体系主要产品线</h3>\n<ul>\n<li>Java Card：支持小程序运行在小内存设备上的平台；</li>\n<li>Java ME：支持 Java 程序运行在移动终端，JDK6 以前被称为 J2ME。基于 Java 语言开发程序 Android 不属于 Java ME。</li>\n<li>Java SE：面向桌面级应用（Windows 下的应用程序）。</li>\n<li>JavaEE：支持多层架构的企业级应用。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "Java",
                "深入理解Java虚拟机"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-1/week-2/",
            "url": "https://maoyifan.github.io/computer-science/java/course-1/week-2/",
            "title": "第2周 判断",
            "date_published": "2020-04-13T11:12:45.000Z",
            "content_html": "<p>:::note info<br />\n 以下为个人学习笔记和习题整理<br />\n课程：零基础学 Java 语言 - 浙江大学 - 翁恺 @ 中国大学 MOOC<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL1pKVS0xMDAxNTQxMDAx\">https://www.icourse163.org/course/ZJU-1001541001</span><br />\n:::</p>\n<h1 id=\"课堂笔记\"><a class=\"anchor\" href=\"#课堂笔记\">#</a> 课堂笔记</h1>\n<h2 id=\"关系运算\"><a class=\"anchor\" href=\"#关系运算\">#</a> 关系运算</h2>\n<ul>\n<li>六个关系运算符：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>==</td>\n<td>相等</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不相等</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于或等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于或等于</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"task-list\">\n<li>关系运算结果为  <code>true</code>  或  <code>false</code></li>\n<li>优先级\n<ul>\n<li>所有关系运算符的优先级比算术运算低，但比赋值运算高</li>\n<li>判断是否相等的 == 和！= 优先级比其他的低</li>\n<li>连续的关系运算是从左到右进行的</li>\n</ul>\n</li>\n<li>判断两个浮点数是否相等的方法<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Math.abs(f1-f2)&lt;<span class=\"number\">0.0000001</span></span><br></pre></td></tr></table></figure></li>\n<li>下列表达式中错误的有？</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\" /><label for=\"cbx_0\"> 5 &gt; 3 == 6 &gt; 4</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_1\"> 6 &gt; 5 &gt; 4</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" disabled=\"true\" /><label for=\"cbx_2\"> a == b == true</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_3\"> a == b == 6</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_4\"> a ==  b &gt; false</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_5\"> (a == b) &gt; false<br />\n <code>true 和 false 不能比较大小</code> </label></li>\n</ul>\n<h2 id=\"判断语句-if-else\"><a class=\"anchor\" href=\"#判断语句-if-else\">#</a> 判断语句 if else</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span>) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多路分支-switch-case\"><a class=\"anchor\" href=\"#多路分支-switch-case\">#</a> 多路分支 switch case</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (type)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        System.out.println(...);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>计算 switch 后面的控制表达式以后，程序会跳到相应的 case，但是如果这个 case 内部没有 break，那么在执行完语句后，就会顺序执行到下面的 case，直到遇到 break 或者 switch 结束。</li>\n</ul>\n<h1 id=\"小测验\"><a class=\"anchor\" href=\"#小测验\">#</a> 小测验</h1>\n<ol>\n<li>\n<p>写出以下代码段的执行结果： {.quiz .essay}<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> num=<span class=\"number\">34</span>, max=<span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( num &gt;= max*<span class=\"number\">2</span> )</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;zhang&quot;</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;huang&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;zhu&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>huang<br />\nzhu</p>\n</blockquote>\n</li>\n<li>\n<p>写出以下代码段的执行结果： {.quiz .essay}<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> limit = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num1 = <span class=\"number\">15</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num2 = <span class=\"number\">40</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( limit &lt;= limit)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( num1 == num2 )</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;lemon&quot;</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;lime&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;grape&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>lime<br />\ngrape</p>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"编程题\"><a class=\"anchor\" href=\"#编程题\">#</a> 编程题</h1>\n<h2 id=\"题目1-时间换算5分\"><a class=\"anchor\" href=\"#题目1-时间换算5分\">#</a> 题目 1. 时间换算（5 分）</h2>\n<ul>\n<li>\n<p><strong>题目内容</strong><br />\n UTC 是世界协调时，BJT 是北京时间，UTC 时间相当于 BJT 减去 8。现在，你的程序要读入一个整数，表示 BJT 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果分小于 10 分，需要保留十位上的 0。如 1124 表示 11 点 24 分，而 905 表示 9 点 5 分，36 表示 0 点 36 分，7 表示 0 点 7 分。</p>\n<p>有效的输入范围是 0 到 2359，即你的程序不可能从测试服务器读到 0 到 2359 以外的输入数据。</p>\n<p>你的程序要输出这个时间对应的 UTC 时间，输出的格式和输入的相同，即输出一个整数，表示 UTC 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果分小于 10 分，需要保留十位上的 0。</p>\n<p><em>提醒：要小心跨日的换算。</em></p>\n</li>\n<li>\n<p><strong>输入格式</strong><br />\n一个整数，表示 BJT 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果小时不是 0 而且分小于 10 分，需要保留十位上的 0。</p>\n</li>\n<li>\n<p><strong>输出格式</strong><br />\n一个整数，表示 UTC 的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于 10，则没有千位部分；如果小时是 0，则没有百位部分；如果小时不是 0 而且分小于 10 分，需要保留十位上的 0。</p>\n</li>\n<li>\n<p><strong>输入样例</strong><br />\n 933</p>\n</li>\n<li>\n<p><strong>输出样例</strong><br />\n 133</p>\n</li>\n</ul>\n<h3 id=\"解题代码\"><a class=\"anchor\" href=\"#解题代码\">#</a> 解题代码</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tScanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> bjt = in.nextInt();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> utc = bjt - <span class=\"number\">800</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(utc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tutc += <span class=\"number\">2400</span>; <span class=\"comment\">// 时为负数，则进行隔日计算</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(utc);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"题目2-信号报告5分\"><a class=\"anchor\" href=\"#题目2-信号报告5分\">#</a> 题目 2. 信号报告（5 分）</h2>\n<ul>\n<li>\n<p><strong>题目内容</strong><br />\n无线电台的 RS 制信号报告是由三两个部分组成的：</p>\n<p>R (Readability) 信号可辨度即清晰度.</p>\n<p>S (Strength)    信号强度即大小.</p>\n<p>其中 R 位于报告第一位，共分 5 级，用 1—5 数字表示.</p>\n<blockquote>\n<p>1---Unreadable</p>\n<p>2---Barely readable, occasional words distinguishable</p>\n<p>3---Readable with considerable difficulty</p>\n<p>4---Readable with practically no difficulty</p>\n<p>5---Perfectly readable</p>\n</blockquote>\n<p>报告第二位是 S，共分九个级别，用 1—9 中的一位数字表示</p>\n<blockquote>\n<p>1---Faint signals, barely perceptible</p>\n<p>2---Very weak signals</p>\n<p>3---Weak signals</p>\n<p>4---Fair signals</p>\n<p>5---Fairly good signals</p>\n<p>6---Good signals</p>\n<p>7---Moderately strong signals</p>\n<p>8---Strong signals</p>\n<p>9---Extremely strong signals</p>\n</blockquote>\n<p>现在，你的程序要读入一个信号报告的数字，然后输出对应的含义。如读到 59，则输出：\t<br />\n <code>\tExtremely strong signals, perfectly readable.\t</code></p>\n</li>\n<li>\n<p><strong>输入格式</strong><br />\n一个整数，信号报告。整数的十位部分表示可辨度，个位部分表示强度。输入的整数范围是 [11,59] 内有效的数字，这个范围外的数字不可能出现在测试数据中。</p>\n</li>\n<li>\n<p><strong>输出格式</strong><br />\n一句话，表示这个信号报告的意义。按照题目中的文字，先输出表示强度的文字，跟上逗号和空格，然后是表示可辨度的文字，跟上句号。注意可辨度的句子的第一个字母是小写的。注意这里的标点符号都是英文的。</p>\n</li>\n<li>\n<p><strong>输入样例</strong><br />\n 33</p>\n</li>\n<li>\n<p><strong>输出样例</strong><br />\n Weak signals, readable with considerable difficulty.</p>\n</li>\n</ul>\n<h3 id=\"解题代码-2\"><a class=\"anchor\" href=\"#解题代码-2\">#</a> 解题代码</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tScanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> rs = in.nextInt();\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> readability = rs / <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> strength = rs % <span class=\"number\">10</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(strength)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Faint signals, barely perceptible&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Very weak signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Weak signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Fair signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Fairly good signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Good signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Moderately strong signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Strong signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;Extremely strong signals&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(readability)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;, unreadable.&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;, barely readable, occasional words distinguishable.&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;, readable with considerable difficulty.&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;, readable with practically no difficulty.&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t\tSystem.out.print(<span class=\"string\">&quot;, perfectly readable.&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "java编程思想"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-1/week-1/",
            "url": "https://maoyifan.github.io/computer-science/java/course-1/week-1/",
            "title": "第1周 计算",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<p>:::note info<br />\n 以下为个人学习笔记和习题整理<br />\n课程：零基础学 Java 语言 - 浙江大学 - 翁恺 @ 中国大学 MOOC<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL1pKVS0xMDAxNTQxMDAx\">https://www.icourse163.org/course/ZJU-1001541001</span><br />\n:::</p>\n<h1 id=\"课堂笔记\"><a class=\"anchor\" href=\"#课堂笔记\">#</a> 课堂笔记</h1>\n<h2 id=\"读输入-字符串输出\"><a class=\"anchor\" href=\"#读输入-字符串输出\">#</a> 读输入、字符串输出</h2>\n<p><figure class=\"highlight java\"><figcaption><span>scanner</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\">...</span><br><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"comment\">// 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(in.nextLine());</span><br><span class=\"line\"><span class=\"comment\">// 让in这个对象做读入下一行的动作，结果交给System.out这个对象去打印一行。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串的 + 用来连接两个字符串形成更长的字符串。</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span> + <span class=\"string\">&quot; world.&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span> + <span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span> + <span class=\"number\">2</span> + <span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(<span class=\"number\">2</span> + <span class=\"number\">3</span> + <span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>tips：</p>\n<ul>\n<li><code>System.out.println</code>  会换行， <code>System.out.print</code>  则不会换行</li>\n<li>出现警告： <code>Resource leak: 'in' is never closed</code> ，可以在函数的最后加入<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in.close();<span class=\"comment\">//释放</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"变量\"><a class=\"anchor\" href=\"#变量\">#</a> 变量</h2>\n<ul>\n<li>\n<p><strong>形式</strong>：&lt;类型名称&gt; &lt; 变量名称 &gt; = &lt; 初始值 &gt;<br />\n <code>int price, amount; // 同时定义两个变量</code> <br />\n <code>int price = 0; // 定义变量并赋值</code> <br />\n <code>int price, amount = 100, age;</code></p>\n</li>\n<li>\n<p><strong>类型名称</strong>：Java 是一种<strong>强类型语言</strong>，所有变量在使用前必须定义或声明，所有变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，程序运行过程中也不能改变变量的类型。</p>\n</li>\n<li>\n<p><strong>变量名称</strong>：又称标识符，只能由字母、数字、下划线构成，数字不能出现在第一个位置。此外，Java 的保留字也不能用作标识符。</p>\n</li>\n<li>\n<p>Java 的保留字列表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>abstract</th>\n<th>do</th>\n<th>implements</th>\n<th>protected</th>\n<th>throws</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>double</td>\n<td>import</td>\n<td>public</td>\n<td>transient</td>\n</tr>\n<tr>\n<td>break</td>\n<td>else</td>\n<td>instanceof</td>\n<td>return</td>\n<td>true</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>extends</td>\n<td>int</td>\n<td>short</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>false</td>\n<td>interface</td>\n<td>static</td>\n<td>while</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>final</td>\n<td>long</td>\n<td>strictfp</td>\n<td>void</td>\n</tr>\n<tr>\n<td>char</td>\n<td>finally</td>\n<td>native</td>\n<td>super</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>class</td>\n<td>float</td>\n<td>new</td>\n<td>switch</td>\n</tr>\n<tr>\n<td>const*</td>\n<td>for</td>\n<td>null</td>\n<td>synchronized</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>goto*</td>\n<td>package</td>\n<td>this</td>\n</tr>\n<tr>\n<td>default</td>\n<td>if</td>\n<td>private</td>\n<td>throw</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"task-list\">\n<li>以下哪些标识符是符合规则的？</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_0\"> currency</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_1\"> lastName</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_2\"> fireplace</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" disabled=\"true\" /><label for=\"cbx_3\"> _last_name</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_4\"> xingmin</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" disabled=\"true\" /><label for=\"cbx_5\"> class</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_6\" disabled=\"true\" /><label for=\"cbx_6\"> goto</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_7\" disabled=\"true\" /><label for=\"cbx_7\"> 4ever</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_8\" disabled=\"true\" /><label for=\"cbx_8\"> time-machine</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_9\" disabled=\"true\" /><label for=\"cbx_9\"> Int</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_10\" disabled=\"true\" /><label for=\"cbx_10\"> $12</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_11\" disabled=\"true\" /><label for=\"cbx_11\"> 我是变量</label></li>\n</ul>\n<h2 id=\"常量-final\"><a class=\"anchor\" href=\"#常量-final\">#</a> 常量 final</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AMOUNT = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">// final是一个修饰符，表示这个变量的值一旦初始化，就不能再修改了。</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"变量类型\"><a class=\"anchor\" href=\"#变量类型\">#</a> 变量类型</h2>\n<h3 id=\"整数-int\"><a class=\"anchor\" href=\"#整数-int\">#</a> 整数 int</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> price = in.nextInt();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果用户输入的不是整数，则会报错  <code>java.util.InputMismatchException</code> 。</li>\n<li>程序要求读入多个数字时，可以在一行输入，中间用空格分开，也可以多行输入。</li>\n<li>每次召唤 <code>in.nextInt()</code> ，它就等待用户输入一个整数。</li>\n<li>两个整数的运算结果只能是整数。</li>\n<li>在 Java 中， <code>10</code>  和 <code>10.0</code>  是完全不同的数。</li>\n</ul>\n<h3 id=\"浮点数-double\"><a class=\"anchor\" href=\"#浮点数-double\">#</a> 浮点数 double</h3>\n<ul>\n<li><strong>浮点数运算有误差</strong>：由于二进制的自身限制，浮点计算需要将十进制先转换为二进制，然后对二进制数进行计算，因此导致误差。</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"number\">1.2</span>-<span class=\"number\">1.1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 结果为 0.09999999999999987</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>整数类型不能表达有小数部分的数；整数运算速度快，占内存小；日常中整数运算多。</li>\n</ul>\n<h2 id=\"赋值运算\"><a class=\"anchor\" href=\"#赋值运算\">#</a> 赋值运算</h2>\n<h3 id=\"强制类型转换\"><a class=\"anchor\" href=\"#强制类型转换\">#</a> 强制类型转换</h3>\n<ul>\n<li>浮点数和整数放在一起运算时，Java 会将整数转换成浮点数，然后进行浮点数运算。</li>\n<li>强制性转换的优先级高于四则运算。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> a = <span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> b = <span class=\"number\">2.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)a/b; <span class=\"comment\">//会报错</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)(a/b); <span class=\"comment\">//不会报错</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"运算符优先级\"><a class=\"anchor\" href=\"#运算符优先级\">#</a> 运算符优先级</h3>\n<ul>\n<li>单目运算符 <code>+</code>   <code>-</code>  优先级最高</li>\n<li>结合关系一般自左向右，单目 <code>+</code>   <code>-</code>  和赋值 <code>=</code>  自右向左。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = a = b = <span class=\"number\">3</span> + c;</span><br><span class=\"line\">result = <span class=\"number\">2</span>;</span><br><span class=\"line\">result = (result = result * <span class=\"number\">2</span>) * <span class=\"number\">6</span> * (result = <span class=\"number\">3</span> + result);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"复合赋值\"><a class=\"anchor\" href=\"#复合赋值\">#</a> 复合赋值</h3>\n<ul>\n<li>5 个算术运算符， <code>+ - * / %</code> ，可以和赋值运算符  <code>=</code>  结合起来，形成复合赋值运算。注意，两个运算符中间不要有空格。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total += (sum+<span class=\"number\">100</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">total = total + (sum+<span class=\"number\">100</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">total * = sum+<span class=\"number\">12</span>;</span><br><span class=\"line\">total = total*(sum+<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">total /= <span class=\"number\">12</span>+<span class=\"number\">6</span>;</span><br><span class=\"line\">total = total / (<span class=\"number\">12</span>+<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure></li>\n<li>递增递减运算符  <code>++</code>   <code>--</code> ，给变量 + 1 或 - 1</li>\n<li>前缀后缀：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">14</span>;</span><br><span class=\"line\">t1 = a++; <span class=\"comment\">// t1先被赋值为 a 即14， a自加到 15</span></span><br><span class=\"line\">t2 = ++a; <span class=\"comment\">// a先自加到 15，t2被赋值为 a 即 15</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"编程题\"><a class=\"anchor\" href=\"#编程题\">#</a> 编程题</h1>\n<h2 id=\"题目1-温度转换5分\"><a class=\"anchor\" href=\"#题目1-温度转换5分\">#</a> 题目 1. 温度转换（5 分）</h2>\n<ul>\n<li>\n<p><strong>题目内容</strong><br />\n写一个将华氏温度转换成摄氏温度的程序，转换的公式是：</p>\n<p><code>°F = (9/5)*°C + 32</code></p>\n<p>其中 C 表示摄氏温度，F 表示华氏温度。</p>\n<p>程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。</p>\n<p>提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式：</p>\n<p><code>(int)x;</code></p>\n<p>其中 x 是要转换的那个浮点数。</p>\n<p><em>注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求转换后的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。</em></p>\n</li>\n<li>\n<p><strong>输入格式</strong><br />\n一个整数。</p>\n</li>\n<li>\n<p><strong>输出格式</strong><br />\n一个整数。</p>\n</li>\n<li>\n<p><strong>输入样例</strong><br />\n 100</p>\n</li>\n<li>\n<p><strong>输出样例</strong><br />\n 37</p>\n</li>\n</ul>\n<h3 id=\"解题代码\"><a class=\"anchor\" href=\"#解题代码\">#</a> 解题代码</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tScanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获得输入的整数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> fahrenheit = in.nextInt();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算摄氏度</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> centigrade = (fahrenheit - <span class=\"number\">32</span>) / (<span class=\"number\">9</span> / <span class=\"number\">5.0</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将浮点数转换为整数输出</span></span><br><span class=\"line\">\t\tSystem.out.println((<span class=\"keyword\">int</span>)centigrade);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "java编程思想"
            ]
        },
        {
            "id": "https://maoyifan.github.io/computer-science/java/course-10/week-1/",
            "url": "https://maoyifan.github.io/computer-science/java/course-10/week-1/",
            "title": "第1周 计算",
            "date_published": "2020-04-12T12:46:25.000Z",
            "content_html": "<p>:::note info<br />\n 以下为个人学习笔记和习题整理<br />\n课程：零基础学 Java 语言 - 浙江大学 - 翁恺 @ 中国大学 MOOC<br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvY291cnNlL1pKVS0xMDAxNTQxMDAx\">https://www.icourse163.org/course/ZJU-1001541001</span><br />\n:::</p>\n<h1 id=\"课堂笔记\"><a class=\"anchor\" href=\"#课堂笔记\">#</a> 课堂笔记</h1>\n<h2 id=\"读输入-字符串输出\"><a class=\"anchor\" href=\"#读输入-字符串输出\">#</a> 读输入、字符串输出</h2>\n<p><figure class=\"highlight java\"><figcaption><span>scanner</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\">...</span><br><span class=\"line\">Scanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\"><span class=\"comment\">// 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(in.nextLine());</span><br><span class=\"line\"><span class=\"comment\">// 让in这个对象做读入下一行的动作，结果交给System.out这个对象去打印一行。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串的 + 用来连接两个字符串形成更长的字符串。</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span> + <span class=\"string\">&quot; world.&quot;</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span> + <span class=\"number\">2</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;Hello&quot;</span> + <span class=\"number\">2</span> + <span class=\"number\">3</span>);</span><br><span class=\"line\">System.out.println(<span class=\"number\">2</span> + <span class=\"number\">3</span> + <span class=\"string\">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>tips：</p>\n<ul>\n<li><code>System.out.println</code>  会换行， <code>System.out.print</code>  则不会换行</li>\n<li>出现警告： <code>Resource leak: 'in' is never closed</code> ，可以在函数的最后加入<br />\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">in.close();<span class=\"comment\">//释放</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"变量\"><a class=\"anchor\" href=\"#变量\">#</a> 变量</h2>\n<ul>\n<li>\n<p><strong>形式</strong>：&lt;类型名称&gt; &lt; 变量名称 &gt; = &lt; 初始值 &gt;<br />\n <code>int price, amount; // 同时定义两个变量</code> <br />\n <code>int price = 0; // 定义变量并赋值</code> <br />\n <code>int price, amount = 100, age;</code></p>\n</li>\n<li>\n<p><strong>类型名称</strong>：Java 是一种<strong>强类型语言</strong>，所有变量在使用前必须定义或声明，所有变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，程序运行过程中也不能改变变量的类型。</p>\n</li>\n<li>\n<p><strong>变量名称</strong>：又称标识符，只能由字母、数字、下划线构成，数字不能出现在第一个位置。此外，Java 的保留字也不能用作标识符。</p>\n</li>\n<li>\n<p>Java 的保留字列表</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>abstract</th>\n<th>do</th>\n<th>implements</th>\n<th>protected</th>\n<th>throws</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>double</td>\n<td>import</td>\n<td>public</td>\n<td>transient</td>\n</tr>\n<tr>\n<td>break</td>\n<td>else</td>\n<td>instanceof</td>\n<td>return</td>\n<td>true</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>extends</td>\n<td>int</td>\n<td>short</td>\n<td>try</td>\n</tr>\n<tr>\n<td>case</td>\n<td>false</td>\n<td>interface</td>\n<td>static</td>\n<td>while</td>\n</tr>\n<tr>\n<td>catch</td>\n<td>final</td>\n<td>long</td>\n<td>strictfp</td>\n<td>void</td>\n</tr>\n<tr>\n<td>char</td>\n<td>finally</td>\n<td>native</td>\n<td>super</td>\n<td>volatile</td>\n</tr>\n<tr>\n<td>class</td>\n<td>float</td>\n<td>new</td>\n<td>switch</td>\n</tr>\n<tr>\n<td>const*</td>\n<td>for</td>\n<td>null</td>\n<td>synchronized</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>goto*</td>\n<td>package</td>\n<td>this</td>\n</tr>\n<tr>\n<td>default</td>\n<td>if</td>\n<td>private</td>\n<td>throw</td>\n</tr>\n</tbody>\n</table>\n<ul class=\"task-list\">\n<li>以下哪些标识符是符合规则的？</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_0\"> currency</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_1\"> lastName</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_2\"> fireplace</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" disabled=\"true\" /><label for=\"cbx_3\"> _last_name</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" checked=\"true\" disabled=\"true\" /><label for=\"cbx_4\"> xingmin</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_5\" disabled=\"true\" /><label for=\"cbx_5\"> class</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_6\" disabled=\"true\" /><label for=\"cbx_6\"> goto</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_7\" disabled=\"true\" /><label for=\"cbx_7\"> 4ever</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_8\" disabled=\"true\" /><label for=\"cbx_8\"> time-machine</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_9\" disabled=\"true\" /><label for=\"cbx_9\"> Int</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_10\" disabled=\"true\" /><label for=\"cbx_10\"> $12</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_11\" disabled=\"true\" /><label for=\"cbx_11\"> 我是变量</label></li>\n</ul>\n<h2 id=\"常量-final\"><a class=\"anchor\" href=\"#常量-final\">#</a> 常量 final</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> AMOUNT = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">// final是一个修饰符，表示这个变量的值一旦初始化，就不能再修改了。</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"变量类型\"><a class=\"anchor\" href=\"#变量类型\">#</a> 变量类型</h2>\n<h3 id=\"整数-int\"><a class=\"anchor\" href=\"#整数-int\">#</a> 整数 int</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> price = in.nextInt();</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>如果用户输入的不是整数，则会报错  <code>java.util.InputMismatchException</code> 。</li>\n<li>程序要求读入多个数字时，可以在一行输入，中间用空格分开，也可以多行输入。</li>\n<li>每次召唤 <code>in.nextInt()</code> ，它就等待用户输入一个整数。</li>\n<li>两个整数的运算结果只能是整数。</li>\n<li>在 Java 中， <code>10</code>  和 <code>10.0</code>  是完全不同的数。</li>\n</ul>\n<h3 id=\"浮点数-double\"><a class=\"anchor\" href=\"#浮点数-double\">#</a> 浮点数 double</h3>\n<ul>\n<li><strong>浮点数运算有误差</strong>：由于二进制的自身限制，浮点计算需要将十进制先转换为二进制，然后对二进制数进行计算，因此导致误差。</li>\n</ul>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.out.println(<span class=\"number\">1.2</span>-<span class=\"number\">1.1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 结果为 0.09999999999999987</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>整数类型不能表达有小数部分的数；整数运算速度快，占内存小；日常中整数运算多。</li>\n</ul>\n<h2 id=\"赋值运算\"><a class=\"anchor\" href=\"#赋值运算\">#</a> 赋值运算</h2>\n<h3 id=\"强制类型转换\"><a class=\"anchor\" href=\"#强制类型转换\">#</a> 强制类型转换</h3>\n<ul>\n<li>浮点数和整数放在一起运算时，Java 会将整数转换成浮点数，然后进行浮点数运算。</li>\n<li>强制性转换的优先级高于四则运算。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> a = <span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> b = <span class=\"number\">2.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)a/b; <span class=\"comment\">//会报错</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = (<span class=\"keyword\">int</span>)(a/b); <span class=\"comment\">//不会报错</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"运算符优先级\"><a class=\"anchor\" href=\"#运算符优先级\">#</a> 运算符优先级</h3>\n<ul>\n<li>单目运算符 <code>+</code>   <code>-</code>  优先级最高</li>\n<li>结合关系一般自左向右，单目 <code>+</code>   <code>-</code>  和赋值 <code>=</code>  自右向左。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = a = b = <span class=\"number\">3</span> + c;</span><br><span class=\"line\">result = <span class=\"number\">2</span>;</span><br><span class=\"line\">result = (result = result * <span class=\"number\">2</span>) * <span class=\"number\">6</span> * (result = <span class=\"number\">3</span> + result);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"复合赋值\"><a class=\"anchor\" href=\"#复合赋值\">#</a> 复合赋值</h3>\n<ul>\n<li>5 个算术运算符， <code>+ - * / %</code> ，可以和赋值运算符  <code>=</code>  结合起来，形成复合赋值运算。注意，两个运算符中间不要有空格。<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total += (sum+<span class=\"number\">100</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">total = total + (sum+<span class=\"number\">100</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">total * = sum+<span class=\"number\">12</span>;</span><br><span class=\"line\">total = total*(sum+<span class=\"number\">12</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">total /= <span class=\"number\">12</span>+<span class=\"number\">6</span>;</span><br><span class=\"line\">total = total / (<span class=\"number\">12</span>+<span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure></li>\n<li>递增递减运算符  <code>++</code>   <code>--</code> ，给变量 + 1 或 - 1</li>\n<li>前缀后缀：<br />\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">14</span>;</span><br><span class=\"line\">t1 = a++; <span class=\"comment\">// t1先被赋值为 a 即14， a自加到 15</span></span><br><span class=\"line\">t2 = ++a; <span class=\"comment\">// a先自加到 15，t2被赋值为 a 即 15</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"编程题\"><a class=\"anchor\" href=\"#编程题\">#</a> 编程题</h1>\n<h2 id=\"题目1-温度转换5分\"><a class=\"anchor\" href=\"#题目1-温度转换5分\">#</a> 题目 1. 温度转换（5 分）</h2>\n<ul>\n<li>\n<p><strong>题目内容</strong><br />\n写一个将华氏温度转换成摄氏温度的程序，转换的公式是：</p>\n<p><code>°F = (9/5)*°C + 32</code></p>\n<p>其中 C 表示摄氏温度，F 表示华氏温度。</p>\n<p>程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。</p>\n<p>提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式：</p>\n<p><code>(int)x;</code></p>\n<p>其中 x 是要转换的那个浮点数。</p>\n<p><em>注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求转换后的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。</em></p>\n</li>\n<li>\n<p><strong>输入格式</strong><br />\n一个整数。</p>\n</li>\n<li>\n<p><strong>输出格式</strong><br />\n一个整数。</p>\n</li>\n<li>\n<p><strong>输入样例</strong><br />\n 100</p>\n</li>\n<li>\n<p><strong>输出样例</strong><br />\n 37</p>\n</li>\n</ul>\n<h3 id=\"解题代码\"><a class=\"anchor\" href=\"#解题代码\">#</a> 解题代码</h3>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tScanner in = <span class=\"keyword\">new</span> Scanner(System.in);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"comment\">// 获得输入的整数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> fahrenheit = in.nextInt();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算摄氏度</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">double</span> centigrade = (fahrenheit - <span class=\"number\">32</span>) / (<span class=\"number\">9</span> / <span class=\"number\">5.0</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将浮点数转换为整数输出</span></span><br><span class=\"line\">\t\tSystem.out.println((<span class=\"keyword\">int</span>)centigrade);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "计算机科学",
                "Java",
                "Spring框架"
            ]
        }
    ]
}